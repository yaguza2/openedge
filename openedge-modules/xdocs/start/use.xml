<?xml version="1.0"?>
<document>

  <properties>
    <title>Using OpenEdge Modules</title>
    <author email="eelco.hillenius@openedge.nl">Eelco Hillenius</author>
  </properties>

  <body>
	
    <section name="Using OpenEdge Modules">
      <p>
		To successfully use OpenEdge Modules, you should know about three things:
		<ul>
			<li>
				how to use types and (init)commands
			</li>
			<li>
				how to use Quartz (if you want to use the sceduler)
			</li>
			<li>
				how to configure Quartz and OpenEdge Modules in
				the environment you need.
			</li>
		</ul>
      </p>
	  
      <subsection name="How to use types and (init)commands">
		<p>
			The default implementation of OpenEdge Modules works with interfaces
			to determine the handling of components. In the framework registered
			interfaces are called types. A component is of a type when it 
			implements its interface. There are two kinds of types, namely 
			'base types' and '(init)commands'.
		</p>
		<p>
			A component will be handled differently by the container (or actually
			a creator delegate) according its type.
			A component allways is-a base type. If a component does not yet have
			a base type assigned, it will be handled as the default type. Also, a 
			component can never be of more than one base type. For example, a
			component never is both a singleton and a throwaway component.
		</p>
		<p>
			The other types, InitCommands, are used for different purposes. A 
			component does not have to have to be of a command type, but
			can be of many, depending on the command implementations.
		</p>
		<p>
			You use commands to be able to decorate components. Eg, a component
			that implements <code>BeanType</code> will have its properties 
			populated from configuration and a component that implements
			<code>DependentType</code> will have its dependencies automatically
			resolved and set as properties.
		</p>
	  </subsection>
	  
	  <subsection name="Default Types">
        <p>
			When you want to use OpenEdge Modules your components don't have to 
			implement any interface... by default.
			Classes that do not implement one of the registered interfaces will be handled as the
			default type. The types and the way they are handled are pluggable, but currently the
			following types are available:<br/>
		<ul>
			<li>
				ThrowAwayType<br/>
				A new instance of the component will be created for each request.
				<br/>
			</li>
			<li>
				SingletonType (default)<br/>
				A singleton component will be created once and only once. 
				All ComponentFactory users share the same instance.
				<br/>
			</li>
			<li>
				ThreadSingletonType<br/>
				A thread singleton component will be created once and only once for each Thread.
				The same instance will be shared in one Thread, but a different 
				instance will be used for each seperate Thread.
				<br/>
			</li>
			<li>
				Job<br/>
				This is exactly the same as a Quartz job. When using the OpenEdge Modules 
				framework:
				<ul>
					<li>
						you have a standard way of configuring Triggers
						on Jobs and passing parameters from configuration as JobDataMaps
					</li>
					<li>
						Jobs and Triggers will be sceduled automatically as defined in the OpenEdge
						Modules configuration
					</li>
				</ul>
				One important thing to remember when using Jobs is that you never get use Jobs
				directly from the ComponentFactory. As we wanted to stay as close as possible to 
				the default Quartz behaviour, we decided to let the Jobs keep their original
				interface and let them be managed completely by the Quartz sceduler. 
				The good news is that the Sceduler (of which the instance you can get
				from the ComponentFactory) has all the functionality you need when working 
				with Jobs and Triggers.
				<br/>
				You still can use Quartz directly instead of through the ComponentFactory. You can even decide
				whether Quartz will be started from the framework.
			</li>
		</ul>
        </p>
      </subsection>
	  
	  <subsection name="Default Commands">
        <p>
			What follows is a list of currently available commands that can be implemented to
			decorate components.
		</p>
		
		<ul>
			<li>
				BeanType<br/>
				A <code>BeanType</code>will have its properties populated from configuration.
				Take class:
		      <source><![CDATA[
public class BeanComponentImpl implements BeanType
{
  private String myString;
  private Integer myInteger;

  public Integer getMyInteger() { return myInteger; }
  public String getMyString() {	return myString; }
  public void setMyInteger(Integer integer) { myInteger = integer; }
  public void setMyString(String string) { myString = string; }
}	
		      ]]></source><br/>
				With configuration snippet:
		      <source><![CDATA[
<component name="BeanTest" class="BeanComponentImpl">

  <property name="myString" value="test"/>
  <property name="myInteger" value="12"/>

</component>
		      ]]></source><br/>
				When you query <code>ComponentFactory</code> for 'BeanTest', you will get
				an instance where the property myInteger has value 12, and
				property myString has value test.
			</li>
		<br/>
		
			<li>
				ConfigurableType<br/>
				A <code>ConfigurableType</code>will be initialised with its XML node of
				the configuration file. Method <code>init(Element)</code> from the 
				<code>Configurable</code> interface
				will be called after creation of a new instance of classes of the 
				<code>ConfigurableType</code>. The component can then decide 
				itself how it wants to interprate the sub nodes.
				Take class:
		      <source><![CDATA[
public class ConfigurableComponentImpl implements ConfigurableType
{
  public void init(Element configNode) throws ConfigException
  {
    Element p1 = configNode.getChild("param1");
    String attr = p1.getAttributeValue("attr");
    Element p2 = configNode.getChild("param2");
    String val = p2.getTextNormalize();
  }
}
		      ]]></source><br/>
				With configuration snippet:
		      <source><![CDATA[
<component name="ConfigurableTest" class="ConfigurableComponentImpl">	
  
  <param1 attr="foo"/>
  <param2>
    Bar
  </param2>		

</component>
		      ]]></source><br/>
				<code>ConfigurableComponentImpl.init(Element)</code> will be called after a new
				instance of ConfigurableComponentImpl is created. 
			</li>
		<br/>
		
			<li>
				org.quartz.Job<br/>
				You make Java component executable by the 
				<a target="_new" href="http://www.part.net/quartz_documentation.html">Quartz</a> 
				scheduler by making it implement the <code>org.quartz.Job</code> interface.
		      <source><![CDATA[
package org.quartz;

public interface Job {

  public void execute(JobExecutionContext context) throws JobExecutionException;
}
		      ]]></source><br/>
				A <code>Job</code>is sceduled with a <code>Trigger</code> 
				(or more triggers) as defined in the configuration file.
				Take class:
		      <source><![CDATA[
public class QuartzJobComponentImpl implements Job
{
  public void execute(JobExecutionContext context) throws JobExecutionException
  {
    JobDataMap dataMap = context.getJobDetail().getJobDataMap();
    String msg1 = (String)dataMap.get("msg1");
    String msg2 = (String)dataMap.get("msg2");
  }
}
		      ]]></source><br/>
				With configuration snippets:
		      <source><![CDATA[
<component name="QuartzTest" class="QuartzJobComponentImpl">

  <jobDetail group="DEFAULT">
    <parameter name="msg1" value="this is a test job"/>
	<parameter name="msg2" value="and another message"/>
  </jobDetail>
		
</component>
		      ]]></source><br/>
				and:
		      <source><![CDATA[
<scheduler properties="/quartz.properties">

  <trigger name="testTrigger" group="DEFAULT" class="org.quartz.SimpleTrigger">
    <parameter name="repeatInterval" value="2000"/>
    <parameter name="repeatCount" value="-1"/>
  </trigger>
	
  <jobExecutionMap>
    <job trigger="testTrigger" component="QuartzTest" />
  </jobExecutionMap>

</scheduler>
		      ]]></source><br/>
				
				The above code and snippets from the configuration file will have the
				following effect:
				<ul>
					<li>
						An <code>org.quartz.JobDetail</code> object will be created that has
						full name <code>DEFAULT.QuartzTest</code> (following the 
						<code>${group}.${name}</code> scheme).
					</li>
					<li>
						 An instance of <code>org.quartz.JobDataMap</code> is
						 created for the job. In the above example the map will
						 contain: <code>{msg1=this is a test job,msg2=and another message}</code>
					</li>
					<li>
						<code>Trigger</code> with (working) name 'testTrigger' is created, with
						properties repeatInterval=2000 and repeatCount=-1.
					</li>
					<li>
						After the ComponentFactory has loaded the components, the Quartz sceduler 
						will be started using quartz.properties (from the classpath root in this case)
						for configuration.
					</li>
					<li>
						After the Sceduler has been started (and all <code>ScedulerObserver</code>s
						are notified of the startup event), the Jobs and Triggers from the configuration 
						are sceduled. In this case, Job <code>QuartzTest</code> 
						(class <code>QuartzJobComponentImpl</code>) is sceduled with Trigger 
						<code>'testTrigger'</code> (class <code>org.quartz.SimpleTrigger</code>).
						As names of sceduled Jobs and Triggers have to be unique within a sceduler,
						the Trigger will have the name <code>'testTrigger_QuartzTest'</code>
						following the scheme <code>${trigger-name}_${job-name}</code>
						<br/>
						With the repeatInterval set to 2000, the Job will execute each 2 seconds,
						and as the repeatCount is -1, the Job will run indefinately.
						<br/>
						An important thing to remember when working with Jobs is that you never
						access Jobs directely from <code>ComponentFactory</code>. Use the
						<code>Quartz Sceduler</code> instead. The following code snippet
						shows how to get the sceduled Job and Trigger from the 
						<code>Sceduler</code>:
		      <source><![CDATA[
Scheduler scheduler = componentFactory.getScheduler();
JobDetail jd = scheduler.getJobDetail("QuartzTest", "DEFAULT");
Trigger t = scheduler.getTrigger("testTrigger_QuartzTest", "DEFAULT");
		      ]]></source><br/>	
					</li>
					Learn more about Quartz 
					<a target="_new" href="http://quartz.sourceforge.net/firstTutorial.html">here</a>
				</ul>
				
			</li>
		<br/>
			
			<li>
				DependentType<br/>
				A component that implements <code>DependentType</code> can have
				dependencies on other components. The dependencies are declared in the 
				configuration file, and will be resolved and check during startup.
		      <source><![CDATA[
public class ComponentUser implements DependentType, ThrowAwayType
{
    private OtherComponent reference = null;

    public OtherComponent getReference()
    {
      return reference;
    }

    public void setReference(OtherComponent reference)
    {
      this.reference = reference;
    }
}

public class OtherComponent
{
    // other stuff
}
		      ]]></source><br/>
				With configuration snippet:
		      <source><![CDATA[
<component name="ComponentA" class="ComponentUser">
  <dependency componentName="ComponentB" propertyName="reference"/>	
</component>

<component name="ComponentB" class="OtherComponent">	
</component>
		      ]]></source><br/>
				During startup, the dependencies will be resolved, and property
				<code>reference</code> will be set to an instance of OtherComponent.
				<br/>
				An exception will be thrown when a cyclic dependency is detected.
			</li>
		<br/>
		
			<li>
				ComponentFactoryObserver<br/>
				A <code>ComponentObserver</code>will be registered as an observer for 
				certain ComponentFactory related events. ComponentObserver itself is a toplevel
				interface. Currently the following concrete observers are available:
				
				<ul>
					<li>
						<code>ComponentsObserver</code> Observers of this type
						will be notified when interesting things happen with components.
					</li>
					<li>
						<code>ScedulerObserver</code>s will be notified when
						<code>Sceduler</code> related things happen.
					</li>
					<li>
						<code>ChainedEventObserver</code>s observe events that are 
						fired by <code>ChainedEventCaster</code>s.
					</li>
				</ul>
				
				Take class:
		      <source><![CDATA[
public class BeanComponentImpl implements BeanType
{
  private String myString;
  private Integer myInteger;

  public Integer getMyInteger() { return myInteger; }
  public String getMyString() {	return myString; }
  public void setMyInteger(Integer integer) { myInteger = integer; }
  public void setMyString(String string) { myString = string; }
}	
		      ]]></source><br/>
				With configuration snippet:
		      <source><![CDATA[
<component name="BeanTest" class="BeanComponentImpl">

  <property name="myString" value="test"/>
  <property name="myInteger" value="12"/>

</component>
		      ]]></source><br/>
				When you query <code>ComponentFactory</code> for 'BeanTest', you will get
				an instance where the property myInteger has value 12, and
				property myString has value test.
			</li>
		<br/>

		</ul><br/>
		
	  </subsection>
	  
	  <!-- //TODO: vergeet niet te vertellen dat tijdens opstarten alle components een keer worden gecreeerd -->
	  
   </section>
 </body>
</document>
