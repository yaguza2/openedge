<?xml version="1.0"?>
<document>

  <properties>
    <title>Using OpenEdge Modules</title>
    <author email="eelco.hillenius@openedge.nl">Eelco Hillenius</author>
  </properties>

  <body>
	
    <section name="Using OpenEdge Modules">
      <p>
		To use OpenEdge Modules, you should know about three things:
		<ul>
			<li>
				how to use types and init-commands
			</li>
			<li>
				how to use Quartz (if you want to use the sceduler)
			</li>
			<li>
				how to use the framework.
			</li>
		</ul>
      </p>
	  
      <subsection name="How to use types and init-commands">
		<p>
			The default implementation of OpenEdge Modules works with interfaces
			to determine the handling of components. Interfacea registered
			with the repository are called types. A component is of a type when it 
			implements its interface. A type is coupled with a factory. This factory
			will be used to get instances when clients query the repository
			for components. Besides a component being a type, components
			can be associated with commands that are executed after component
			instantiation (depending on it type factory).
		</p>
		<p>
			A component will be handled differently by the container (or actually
			its factory delegate) according to its type. A component allways is-a type. 
			If a component does not yet have a base type assigned, it will be 
			handled as the registered default type. Also, a component can never 
			be of more than one base type. For example, a component never is 
			both a singleton and a throwaway component.
		</p>
		<p>
			InitCommands are used for different purposes. A component can be
			associated with zero of more commands for extra initialization (hence
			the name InitCommands). Using the default implementation, 
			components that want to be associated with a command should
			implement	the appropriate inteface.
		</p>
		<p>
			You use InitCommands to be able to decorate components. Eg, a component
			that implements <code>BeanType</code> will have its properties 
			populated from configuration and a component that implements
			<code>DependentType</code> will have its dependencies automatically
			resolved and set as properties.
		</p>
	  </subsection>
	  
	  <subsection name="Standard Types">
        <p>
			When you want to use OpenEdge Modules your components don't have to 
			implement any interface... by default. Classes that do not implement one 
			of the registered interfaces will be handled as the default type. 
			The types and the way they are handled are pluggable, but currently the
			following types are available:<br/>
		<ul>
			<li>
				ThrowAwayType<br/>
				A new instance of the component will be created for each request.
				<br/>
			</li>
			<li>
				SingletonType (default)<br/>
				A singleton component will be created once at startup and users 
				share the same instance.
				<br/>
			</li>
			<li>
				ThreadSingletonType<br/>
				A thread singleton component will be created once for each Thread.
				The same instance will be shared in one Thread, but a different 
				instance will be used for each seperate Thread.
				<br/>
			</li>
			<li>
				Job<br/>
				This is exactly the same as a Quartz job. When using the OpenEdge Modules 
				framework:
				<ul>
					<li>
						you have a standard way available of configuring Triggers
						on Jobs and passing parameters from configuration as JobDataMaps
					</li>
					<li>
						Jobs and Triggers will be sceduled automatically as defined in the OpenEdge
						Modules configuration
					</li>
				</ul>
				One important thing to remember when using Jobs is that you never use Jobs
				directly from the ComponentRepository. As we wanted to stay as close as possible to 
				the default Quartz behaviour, we decided to let the Jobs keep their original
				interface and let them be managed completely by the Quartz sceduler. 
				The good news is that the Sceduler (of which the instance you can get
				from the ComponentRepository) has all the functionality you need when working 
				with Jobs and Triggers.
				<br/>
				You still can use Quartz directly instead of through the ComponentRepository. You can even decide
				whether Quartz will be started from the framework.
			</li>
		</ul>
        </p>
      </subsection>
	  
	  <subsection name="Standard Commands">
        <p>
			What follows is a list of currently available commands that can be implemented to
			decorate components.
		</p>
		
		<ul>
			<li>
				BeanType<br/>
				A <code>BeanType</code>will have its properties populated from configuration.
				Take class:
		      <source><![CDATA[
public class BeanComponentImpl implements BeanType
{
  private String myString;
  private Integer myInteger;

  public Integer getMyInteger() { return myInteger; }
  public String getMyString() {	return myString; }
  public void setMyInteger(Integer integer) { myInteger = integer; }
  public void setMyString(String string) { myString = string; }
}	
		      ]]></source><br/>
				With configuration snippet:
		      <source><![CDATA[
<component name="BeanTest" class="BeanComponentImpl">

  <property name="myString" value="test"/>
  <property name="myInteger" value="12"/>

</component>
		      ]]></source><br/>
				When you query <code>ComponentRepository</code> for 'BeanTest', you will get
				an instance where the property myInteger has value 12, and
				property myString has value test.
			</li>
		<br/>
		
			<li>
				ConfigurableType<br/>
				A <code>ConfigurableType</code>will be initialised with its (JDom) XML node of
				the configuration file. Method <code>init(Element)</code> from the 
				<code>Configurable</code> interface
				will be called after creation of a new instance of classes of the 
				<code>ConfigurableType</code>. The component can then decide 
				itself how it wants to interprate the sub nodes.
				Take class:
		      <source><![CDATA[
public class ConfigurableComponentImpl implements ConfigurableType
{
  public void init(Element configNode) throws ConfigException
  {
    Element p1 = configNode.getChild("param1");
    String attr = p1.getAttributeValue("attr");
    Element p2 = configNode.getChild("param2");
    String val = p2.getTextNormalize();
  }
}
		      ]]></source><br/>
				With configuration snippet:
		      <source><![CDATA[
<component name="ConfigurableTest" class="ConfigurableComponentImpl">	
  
  <param1 attr="foo"/>
  <param2>
    Bar
  </param2>		

</component>
		      ]]></source><br/>
				<code>ConfigurableComponentImpl.init(Element)</code> will be called after a new
				instance of ConfigurableComponentImpl is created. 
			</li>
		<br/>
		
			<li>
				org.quartz.Job<br/>
				You make Java component executable by the 
				<a target="_new" href="http://www.part.net/quartz_documentation.html">Quartz</a> 
				scheduler by making it implement the <code>org.quartz.Job</code> interface.
		      <source><![CDATA[
package org.quartz;

public interface Job {

  public void execute(JobExecutionContext context) throws JobExecutionException;
}
		      ]]></source><br/>
				A <code>Job</code>is sceduled with a <code>Trigger</code> 
				(or more triggers) as defined in the configuration file.
				Take class:
		      <source><![CDATA[
public class QuartzJobComponentImpl implements Job
{
  public void execute(JobExecutionContext context) throws JobExecutionException
  {
    JobDataMap dataMap = context.getJobDetail().getJobDataMap();
    String msg1 = (String)dataMap.get("msg1");
    String msg2 = (String)dataMap.get("msg2");
  }
}
		      ]]></source><br/>
				With configuration snippets:
		      <source><![CDATA[
<component name="QuartzTest" class="QuartzJobComponentImpl">

  <jobDetail group="DEFAULT">
    <parameter name="msg1" value="this is a test job"/>
	<parameter name="msg2" value="and another message"/>
  </jobDetail>
		
</component>
		      ]]></source><br/>
				and:
		      <source><![CDATA[
<scheduler properties="/quartz.properties">

  <trigger name="testTrigger" group="DEFAULT" class="org.quartz.SimpleTrigger">
    <property name="repeatInterval" value="2000"/>
    <property name="repeatCount" value="-1"/>
  </trigger>
	
  <jobExecutionMap>
    <job trigger="testTrigger" component="QuartzTest" />
  </jobExecutionMap>

</scheduler>
		      ]]></source><br/>
				
				The above code and snippets from the configuration file will have the
				following effect:
				<ul>
					<li>
						An <code>org.quartz.JobDetail</code> object will be created that has
						full name <code>DEFAULT.QuartzTest</code> (following the 
						<code>${group}.${name}</code> scheme).
					</li>
					<li>
						 An instance of <code>org.quartz.JobDataMap</code> is
						 created for the job. In the above example the map will
						 contain: <code>{msg1=this is a test job,msg2=and another message}</code>
					</li>
					<li>
						<code>Trigger</code> with (working) name 'testTrigger' is created, with
						properties repeatInterval=2000 and repeatCount=-1.
					</li>
					<li>
						After the ComponentRepository has loaded the components, the Quartz sceduler 
						will be started using quartz.properties (from the classpath root in this case)
						for configuration.
					</li>
					<li>
						After the Sceduler has been started (and all <code>ScedulerObserver</code>s
						are notified of the startup event), the Jobs and Triggers from the configuration 
						are sceduled. In this case, Job <code>QuartzTest</code> 
						(class <code>QuartzJobComponentImpl</code>) is sceduled with Trigger 
						<code>'testTrigger'</code> (class <code>org.quartz.SimpleTrigger</code>).
						As names of sceduled Jobs and Triggers have to be unique within a sceduler,
						the Trigger will have the name <code>'testTrigger_QuartzTest'</code>
						following the scheme <code>${trigger-name}_${job-name}</code>
						<br/>
						With the repeatInterval set to 2000, the Job will execute each 2 seconds,
						and as the repeatCount is -1, the Job will run indefinately.
						<br/>
						An important thing to remember when working with Jobs is that you never
						access Jobs directely from <code>ComponentRepository</code>. Use the
						<code>Quartz Sceduler</code> instead. The following code snippet
						shows how to get the sceduled Job and Trigger from the 
						<code>Sceduler</code>:
		      <source><![CDATA[
Scheduler scheduler = componentFactory.getScheduler();
JobDetail jd = scheduler.getJobDetail("QuartzTest", "DEFAULT");
Trigger t = scheduler.getTrigger("testTrigger_QuartzTest", "DEFAULT");
		      ]]></source><br/>	
					</li>
					Learn more about Quartz 
					<a target="_new" href="http://quartz.sourceforge.net/firstTutorial.html">here</a>
				</ul>
				
			</li>
		<br/>
			
			<li>
				DependentType<br/>
				A component that implements <code>DependentType</code> can have
				dependencies on other components. The dependencies are declared in the 
				configuration file, and will be resolved and checked during startup.
		      <source><![CDATA[
public class ComponentUser implements DependentType, ThrowAwayType
{
    private OtherComponent reference = null;

    public OtherComponent getReference()
    {
      return reference;
    }

    public void setReference(OtherComponent reference)
    {
      this.reference = reference;
    }
}

public class OtherComponent
{
    // other stuff
}
		      ]]></source><br/>
				With configuration snippet:
		      <source><![CDATA[
<component name="ComponentA" class="ComponentUser">
  <dependency componentName="ComponentB" propertyName="reference"/>	
</component>

<component name="ComponentB" class="OtherComponent">	
</component>
		      ]]></source><br/>
				During startup, the dependencies will be resolved, and property
				<code>reference</code> will be set to an instance of OtherComponent.
				<br/>
				An exception will be thrown when a cyclic dependency is detected.
			</li>
		<br/>
		
			<li>
				ComponentRepositoryObserver<br/>
				A <code>ComponentRepositoryObserver</code> will be registered as an observer for 
				certain ComponentRepository related events. ComponentObserver itself is a toplevel
				interface. Currently the following concrete observers are packeged with the
				distribution:
				
				<ul>
					<li>
						<code>ComponentObserver</code>s will be notified when 
						interesting things happen with components.
					</li>
					<li>
						<code>ScedulerObserver</code>s will be notified when
						<code>Sceduler</code> related things happen.
					</li>
					<li>
						<code>ChainedEventObserver</code>s observe events that are 
						fired by <code>ChainedEventCaster</code>s.
					</li>
				</ul>
				
				Take class:
		      <source><![CDATA[
public class SchedulerObserverImpl implements SchedulerObserver
{	
  private SchedulerStartedEvent evt;
	
  public void schedulerStarted(SchedulerStartedEvent evt)
  {
    this.evt = evt;
	System.out.println("scheduler was started!");
  }
}
		      ]]></source><br/>
				With configuration snippet:
		      <source><![CDATA[
<component name="SchedulerObserverTest" class="SchedulerObserverImpl"/>
		      ]]></source><br/>
				When the Sceduler has been started, the componentFactory fires the
				SchedulerStartedEvent to all registered observers. As SchedulerObserverImpl
				implements the SchedulerObserver, it will be automatically registrated and
				thus recieves the event.
			</li>
		<br/>
			
			<li>
				ChainedEventCaster<br/>
				A <code>ChainedEventCaster</code> will have the component
				repository registred as a ChainedEventObserver. Combine this with
				other observers for chained event, en whenever a chained event 
				caster fires an event, all chained event observers will have the
				event delivered. This makes it easy to implement complex 
				synchronious messaging in your systems without the usual 
				hassle of (programmatic) configuration. 
				<br/>
				For example, if you have a critical module in your web application that
				should to notify the controller servlet when something is dead-wrong
				(like when database connections fail), it could notify the controller
				component, that could in turn display a 'temporarily unavailable' page
				until the critical component is up for service again. In this example,
				the critical module implements interface ChainedEventCaster and the 
				controller component implements ChainedEventObserver.
			
			</li>
		<br/>

		</ul><br/>
		
	  </subsection>
	  
      <subsection name="How to use Quartz">
		<p>
			As a standard facility, you can use Jobs and Triggers with OpenEdge modules as described earlier.
			For more information on how to use the Quartz framework, see
			<a target="_new" href="http://www.part.net/quartz_documentation.html">their site</a>
		</p>
	  </subsection>
	  
      <subsection name="How to use the framework">
		<p>
			The following section shows how you can use the framework.
		</p>
		
		<subsection name="Initializing">
			<p>
				Before you can use the framework, you have to initialize it. You do this by constructing 
				a JDOMConfigurator object. JDOMConfigurator has different constructors that might suit
				your need depending on your situation.
			<p>
			</p>
				For example, you could have a startup/ main servlet that does this:
	 		      <source><![CDATA[
	public void init(ServletConfig config) throws ServletException
	{
	   new nl.openedge.modules.JDOMConfigurator(config.getServletContext());
	 }
	 			]]></source><br/>
				and have this in your web.xml:
	 		      <source><![CDATA[
	&lt;servlet&gt;
	  &lt;servlet-name&gt;Application&lt;/servlet-name&gt;
	  &lt;servlet-class&gt;com.foo.bar.ApplicationServlet&lt;/servlet-class&gt;
	  &lt;init-param&gt;
	    &lt;param-name&gt;oemodules.configFile&lt;/param-name&gt;
	    &lt;param-value&gt;WEB-INF/oemodules.xml&lt;/param-value&gt;
	 &lt;/init-param&gt;
	 &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
	&lt;/servlet&gt;
	 ]]></source><br/>
			</p>
		</subsection>
		
		<subsection name="Getting Components">
			<p>
				You can get an instance of the component repository like this:
			<source><![CDATA[
ComponentRepository crepo = RepositoryFactory.getRepository();			
			]]></source>
			</p>
			<p>
				Alternatively, if you set the JNDI name like
			<source><![CDATA[
<jndi name="myLocation"/>
			]]></source>
				in your configuration file, you can use the following snippet:
			<source><![CDATA[
Context ctx = new InitialContext();
ComponentRepository crepo = (ComponentRepository)ctx.lookup("myLocation");
			]]></source>
			</p>
			<p>
				Keep in mind that at time of writing the framework was build and tested for
				single VM use. As we (the creators of the framework) use it for constructing
				a logic/ bussiness functionallity layer with it, where the components are
				service centric, not datacentric, duplicates accross VMs are not a problem
				for us. But... if you have any suggestions on how to improve these and other
				aspects on the framework, you're welcome to comment!
			</p>
			</subsection>
		
	  </subsection>
	
   </section>
 </body>
</document>
