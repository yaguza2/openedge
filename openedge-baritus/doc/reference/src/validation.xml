<chapter id="validation">

    <title>Validation</title>
    
	<para>
		This chapter explains validation.
	</para>
	
	<sect1 id="validation-s1">
        <title>After population</title>
		
	    <para>
			The first pass in the population process is the conversion of request parameters etc. to
			Java objects and populating the provided form bean with those objects.
			If this is successful, you know that inputs for integers, dates, etc. conform to a
			valid form (e.g. 'foo' is not a valid integer, but '12' is).
	    </para>
		
		<para>
			Next, you might want to check if, for instance, a provided parameter not only is a
			valid integer, but is also greater than say 10. Or that a parameter not only is
			a valid date, but that this date also is after today. If we talk about validation, we mean
			this kind of checks.
		</para>
		
		<para>
			Validation can be performed on two levels: field and form level. Field level validation is related to 
			one input field (e.g. a request parameter) at a time. 
			Form level validation is executed regardles the provided parameters.
		</para>

		<para>
			Furthermore, whether a validation action is executed can be made dependend of a certain
			state (like the value a parameter) using 
			<literal>nl.openedge.baritus.validation.ValidationActivationRule</literal>s.
		</para>
		
	</sect1>
	
	<sect1 id="validation-s2">
		<title>An example</title>
		
		<para>
			Let us start with an example that displays some usages of the validation mechanism
			of Baritus. In the following example, we want to validate that not only myInteger is
			a valid integer, but also that the integer allways has a value that is greater than ten.
		
		<programlisting><![CDATA[
public class FooForm
{
	private Integer myInteger;
	
	public Integer getMyInteger() { return myInteger; }
	public void setMyInteger(Integer i) { myInteger = i; }
}
]]></programlisting>
			
		</para>
		<para>
			
			The validator:
			
		<programlisting><![CDATA[
public class BarValidator extends AbstractFieldValidator
{
	public boolean isValid(
		ControllerContext cctx, 
		FormBeanContext formBeanContext, 
		String fieldName, 
		Object value)
	{
		// note that type conversion is allready done by the population process
		Integer val = (Integer)value; 
		// the value can still be null though
		return(val != null && val.intValue() > 10); 
	}
	
	public String getErrorMessage(
		ControllerContext cctx, 
		FormBeanContext formBeanContext, 
		String fieldName,
		Object value, 
		Locale locale)
	{
		// this method will be called in case isValid returned false
		return "input " + value + 
			" is not valid; please provide a number larger than 10";
	}
}
]]></programlisting>

		</para>
		<para>
			
			If getErrorMessage returns null, no error will be saved by Baritus. 
			This can be convenient when there is more than one possible
			error message. You should set errors directly in the 
			formBeanContext during execution of isValid instead. A
			re-write of a validator that saves the error directly in the
			formBeanContext looks like this:
			
		<programlisting><![CDATA[
public class BarValidator extends AbstractFieldValidator
{
	public boolean isValid(
		ControllerContext cctx, 
		FormBeanContext formBeanContext, 
		String fieldName, 
		Object value)
	{
		// note that type conversion is allready done by the population process
		Integer val = (Integer)value; 
		// the value can still be null though
		boolean valid = (val != null && val.intValue() > 10); 
		
		if(!valid)
		{
			String errorMessage = "input " + value + 
				" is not valid; please provide a number larger than 10";
			formBeanContext.setError(fieldName, errorMessage);
		}
		
		return valid;
	}
	
	public String getErrorMessage(
		ControllerContext cctx, 
		FormBeanContext formBeanContext, 
		String fieldName,
		Object value, 
		Locale locale)
	{
		return null; // will be ignored by Baritus
	}
}
]]></programlisting>

		</para>
		<para>
			
			Now, register it with your control:
			
		<programlisting><![CDATA[
public class MyCtrl extends FormBeanCtrl
{
	...
	
	public void init(Element controllerNode) throws ConfigException
	{
		addValidator("myInteger", new BarValidator());
		...
	}
	
	...
}
]]></programlisting>

		</para>
		<para>
			
			And a crude example of how you can use it with a velocity template:
			
		<programlisting><![CDATA[
<input type="text" name="myInteger"
	#if( $model.errors.get('myInteger') ) class="fielderror" #else class="field" #end
	value="$!{model.displayProperty('myInteger')}">

<br>
#if( $model.errors.get('myInteger')  )  
	<span class="error"> ${model.errors.get('myInteger') } </span>
#end
]]></programlisting>
						
		</para>
		
	</sect1>
	
	<sect1 id="validation-s3">
        <title>Mapped and indexed properties</title>
		
	    <para>
			When using mapped or indexed properties, you have two options of registering field validators,
			on target name and/ or on flat name. Let's illustratie this by example:
			
		<programlisting><![CDATA[
public class FormWithMap
{
	private Map foo = new HashMap();
	
	public Integer getfoo() { return foo; }
	public void setfoo(Map m) { foo = m; }
}
]]></programlisting>

		</para>
		<para>

			Not only can we register validators with the whole target name, including the keys
			or indexes like this:

		<programlisting><![CDATA[
...
	addValidator("foo(bar)", myValidator);
	addValidator("foo(someOtherKey", myOtherValidator);
...
]]></programlisting>

		</para>
		<para>

			
			But in case the validator should be executed for all keys (or indexes), the 'flat name'
			(name without markup for map/ index navigation) as well like:

		<programlisting><![CDATA[
...
	addValidator("foo", myValidatorForAllKeys);
...
]]></programlisting>
			
	    </para>
		
	</sect1>
	
</chapter>

