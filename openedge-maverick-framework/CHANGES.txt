1.2.2
-------------------------------------------------

- Added Map to method isNullOrEmpty
- Removed method getPrefixedFieldsFromRequest. Uses (like checkboxes) 
	of this method should be replaced with a Map.

1.2.1
-------------------------------------------------

- Added a final fallthough for converting; if no Converter is found in the lookup, the registry
	returns an instance of NoopConverter, which does absolutely nothing besides returning
	the input value unaltered.
	
- Fixed a bug in the population process that prevented working with mapped values (and
	(had the potential of errors when working with indexed values).

-------------------------------------------------
1.2

- Velocity tool nl.openedge.maverick.framework.velocity.tools.FieldTool is removed.
		
	$!{fieldTool.getFormValueAsString($model, $displayfieldname)} should be replaced with:
	$!{model.displayProperty($fieldname)}
	
	and
	$!{fieldTool.getFormattedFormValueAsString($model, $fieldname, $pattern)} should be replaced with:
	$!{model.displayProperty($fieldname, $pattern)}

- Converters are now used with a registry nl.openedge.maverick.ConverterRegistry.
	The converters that are registered with BeanUtils are only used as a fallthrough.
	Form population can now be used in a localized environment, and is not dependent
	on the current BeanUtils registration. Converters are looked up with the following
	algoritm:
	
		1. If a locale is given the first search is for a converter that was
			registered for the given type and locale. 
		2. If it is not found, the second search is for any converter of the 
			type LocaleConverter that was registered for the given type. If it 
			is found, a new instance will be created for the given locale, the 
			pattern will be copied if possible and the newly instantiated converter 
			will be registered for the given type and locale (and thus will be 
			found at the first search next time). 
		3. If it is not found, the search is the same as when no locale was given 
			(locale == null): the 'normal', not localized registry will be searched 
			for an entry with the given type. 
		4. If this is not found either, a lookup with ConvertUtils from Jakarta 
			Commons BeanUtils will be done as a fallthrough.
			
- Formatting of property values will be done as follows:
	If an object was found for the given property name, it will be formatted with the 
	formatter found as follows:
	
		1. look in the ConverterRegistry if a formatter was stored with the fieldname
	 			and optionally locale as key.
	 	2. if not found, look in the ConverterRegistry if a formatter was stored with
	 			the pattern and optionally the locale as key.
	 	3. if not found, look in the ConverterRegistry if a Converter was stored for the 
	 			type of the property that implements Formatter (as well as Converter). 
	 			
	If a formatter was found, it will be used for formatting the property 
	(using the format(property, pattern) method). If not, ConvertUtils of the 
	BeanUtils package is used to get the string representation of the property.
			
- Formatting of objects can be done skipping the lookup of a corresponding property
	in the current form. This can be used for formatting arbitrary objects in a manner
	that is consistent with the rest of the webapp. The formatting algoritm is the same
	as with the formatting of property values as described above.

- custom field populators can be registered on field level and on regexp level. 
	Besides extra flexibility, this has a special security releated purpose: 
	you might want to 'block' the population of certain properties like id's etc. 
	The population is done like this:
	
		1. if any regexp populators were registered, for all fields that are matched, 
			these populators are used and the fields are removed from the list of
			parameters to process.
		2. for the remainder of the parameters: see if a custom field populator is 
			registered for the current field name. If found, use this populator, if not:
		3. use the default populator.
	
- the current locale is stored in AbstractForm. The current locale is found with 
	the protected method getLocaleForRequest in AbstractCtrl and works as following:
		
		1. if a java.security.Principal was saved in the form (getUserPrincipal) AND
			the principal is an instance of nl.openedge.access.UserPrincipal, it's Locale
			will be used. 
		2. if a Locale was saved in the HttpSession object with key _currentLocale this value
			will be used, overriding the former found Locale if one was found.
		3. if the two above actions did not result in a Locale, the browser preferences
			that are sent with the request are used (HttpServletRequest.getLocale()).
			
- The principal that is optionally saved in the form is now of type java.security.Principal
	instead of (implementing class) nl.openedge.access.UserPrincipal. This gives you greater
	flexibility with which authorization model to work. 

- moved velocity tools from package 'nl.openedge.maverick.framework.util' to
	'nl.openedge.maverick.framework.velocity.tools'. Users should at least update
	their velocity tools configuration.
	
- minor performance enhancements with population.

- fixed bug that prevented working with arrays correctly

- various minor bugfixes.


-------------------------------------------------
1.1

First (numbered) release

- Validators on field and form level (validateForm is now deprecated and will be removed in 1.3).

- Form population.

- Error handling.

- Etc.