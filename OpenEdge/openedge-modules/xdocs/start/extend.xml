<?xml version="1.0"?>
<document>

  <properties>
    <title>Extending OpenEdge Modules</title>
    <author email="eelco.hillenius@openedge.nl">Eelco Hillenius</author>
  </properties>

  <body>
    <section name="Extending the framework">
      <p>
		If you miss certain types or InitCommands, you can register your
		own. Additionally, if you don't like the two default ComponentRepository
		implementations, you can provide your own version
		(though within some constraints).
      </p>
	  <subsection name="types registries">
		<p>
			The two default implementations of ComponentRepository use their
			own TypesRegistry. Depending on the implementation you use, you
			work with a TypesRegistry to register your own types and InitCommands.
		</p>
	  </subsection>
	  <subsection name="implementing your own types">
		<p>
			To create your own type, you need two things: an interface and a factory.
			For example, we take the ThrowAwayType that creates a new instance of
			a component on each request.
		</p>
		<p>
			First we need the type interface to be able to regconize the type and 
			find the needed factory for it. Mind you that this is not needed if you 
			use the loosely typed implementation of the ComponentRepository.
			<source><![CDATA[
public interface ThrowAwayType
{

}
			]]></source><br/>
			That done, we need a factory to actually create instances of the components.<br/>
			A factory needs to Implement <code>ComponentFactory</code>.
			<source><![CDATA[
public interface ComponentFactory
{

  public void setComponentClass(Class componentClass) throws ConfigException;
	
  public String getName();
	
  public void setName(String name);
	
  public Class getComponentClass();

  public ComponentRepository getComponentRepository();
	
  public void setComponentRepository(ComponentRepository factory);
	
  public abstract InitCommand[] getInitCommands();

  public void setInitCommands(InitCommand[] commands);

  public Object getComponent() throws ComponentLookupException;
	
  public void setComponentNode(Element componentNode) throws ConfigException;

}
			]]></source><br/>
			
			You can extend from <code>AbstractComponentFactory</code> so
			that you have the default behavoir except the <code>getComponent()</code>
			method implemented.<br/>
			
			Beneath you find the factory implementation for ThrowAwayType.
			
			<source><![CDATA[
public class ThrowAwayTypeFactory extends AbstractComponentFactory
{

  public Object getComponent() throws ComponentLookupException
  {
    
	Object instance = null;
    
	try
      {
        instance = componentClass.newInstance();
      }
      catch (InstantiationException ex)
      {
        throw new ComponentLookupException(ex);
      }
      catch (IllegalAccessException ex)
      {
        throw new ComponentLookupException(ex);
      }
      
	  try
      {
        executeInitCommands(instance);
      }
      catch (InitCommandException e)
      {
        e.printStackTrace();
        throw new ComponentLookupException(e);
      }
      catch (ConfigException e)
      {
        e.printStackTrace();
        throw new ComponentLookupException(e);
      }
      
	  return instance;
    }
}
			]]></source><br/>
		Now, if this was really a new type, we would have to register it with 
		the right TypesRegistry like:
			<source><![CDATA[
TypesRegistry.registerComponentType(ThrowAwayType.class, ThrowAwayTypeFactory.class);
			]]></source><br/>
		
		You have to do this before initializing, or you call either <code>reload()</code>
		on your instance of <code>JDOMConfigurator</code> or <code>reset()</code> on
		on the <code>RepositoryFactory</code>.
		</p><br/>
	  
	  </subsection>
	  
	  <subsection name="implementing your own InitCommands">
		<p>
			To create an InitCommand, you have to create a type (if you use the default
			implementation of ComponentRepository) and an InitCommand implementation.
		</p>
		<p>
			Creating a type works the same as above; just create an interface.
			<source><![CDATA[
public interface MyType
{
  public void setMessage(String message);
}
			]]></source><br/>			
			
			Then create the InitCommand. InitCommands have to implement the 
			<code>InitCommand</code> interface:
			<source><![CDATA[
public interface InitCommand
{
  public void init(
    String componentName, 
    Element componentNode,
    ComponentRepository moduleFactory)
    throws ConfigException; 

  public void execute(Object componentInstance)
    throws InitCommandException, ConfigException;
}
			]]></source><br/>	
			Here's an implementation of the InitCommand for our new type
			
			<source><![CDATA[
public class MyTypeInitCommand implements InitCommand
{
  public void init(
    String componentName, 
    Element componentNode,
    ComponentRepository moduleFactory)
    throws ConfigException
    {
      // nothing here
    }

    public void execute(Object componentInstance) 
      throws InitCommandException, ConfigException
    {
    if(componentInstance instanceof MyType)
    {
      ((MyType)componentInstance).setMessage("Hello World");	
    }
    else
    {
      throw new ConfigException("loosely typed components are not supported for this case");
    }
  }
}
			]]></source><br/>
			
			Now our startup code could be like this:
		
			<source><![CDATA[
// register out new custom init command type
TypesRegistry.registerInitCommand(MyType.class, MyTypeInitCommand.class);
// now load the components
JDOMConfigurator c = new JDOMConfigurator(url);
// get the component repository
ComponentRepository crep = RepositoryFactory.getRepository();
// get the component of our new type. The initcommand should have been executed
// at least once depending on the base type.
MyTypeImpl module = (MyTypeImpl)crep.getComponent("MyTypeTest");
			]]></source><br/>
			
			And we're ready to use our new InitCommand!
			
		</p>
	  </subsection>
	  
    </section>
  </body>
</document>
