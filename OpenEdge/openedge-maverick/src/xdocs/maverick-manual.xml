<?xml version="1.0"?>

<!--
	$Id: maverick-manual.xml,v 1.27 2004/06/27 17:42:15 eelco12 Exp $
	$Source: /cvsroot-fuse/mav/maverick/src/xdocs/maverick-manual.xml,v $

	Theoretically, this is Docbook markup.
-->

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
				"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">

<book>
	<bookinfo>
		<mediaobject>
			<imageobject>
				<imagedata fileref="images/MaverickLogo.gif"
							align="left"
							srccredit="mike@meltmedia.com"/>
			</imageobject>
		</mediaobject>

		<title>Maverick</title>

		<authorgroup>
			<author><firstname>Jeff</firstname><surname>Schnitzer</surname></author>
			<author><firstname>Scott</firstname><surname>Hernandez</surname></author>
			<author><firstname>Jim</firstname><surname>Moore</surname></author>
		</authorgroup>

		<copyright>
			<year>2001</year>
			<year>2002</year>
			<holder>Infohazard.org</holder>
		</copyright>

		<pubdate>$Date: 2004/06/27 17:42:15 $</pubdate>
		<releaseinfo>$Revision: 1.27 $</releaseinfo>
	</bookinfo>
	
	<preface>
		<title>Preface</title>
		
		<para>
			Maverick is a Model-View-Controller (aka "Model 2") framework for web
			publishing using Java and J2EE.  It is a minimalist framework
			which focuses solely on MVC logic, allowing you to generate
			presentation using a variety of templating and transformation technologies.
		</para>
		
		<para>
			In principle it combines the best features of Struts, WebWork, and
			Cocoon2, however:
		</para>
		
		<itemizedlist spacing="compact">
			<listitem>
				<para>
					Maverick is simple to use - this is a minimalist framework that anyone
					can understand easily.  This is not a "kitchen sink" framework
					that tries to provide everything you need to build a web
					application; there are plenty of great database connection pools,
					application servers, validation frameworks, templating languages,
					etc already out there.
				</para>
			</listitem>
			<listitem>
				<para>
					Maverick is simple to understand - the code is easy to understand,
					there's not a lot of it, and it's designed with pluggability
					and extendability in mind.  The idea of a Controller that builds
					a Model that gets rendered by a View is very simple and
					straightforward, so the framework should be too.
				</para>
			</listitem>
			<listitem>
				<para>
					Maverick is agnostic about view technologies - you can use any templating
					engine you like with Maverick.  Examples are provided for JSP
					(with JSTL - no need for special tag libaries), Velocity,
					and Domify/XSLT.  The developers of Maverick actively use all three
					of these in their "real life" to build web applications.
				</para>
			</listitem>
			<listitem>
				<para>
					You can run your view output through a pipeline of transformations.
					Maverick-supplied transformations include XSLT, DVSL, "wrapping" layout
					transformations, FOP, and Perl.  You can efficiently chain many
					transformations of various types together, and you can specify
					this on a per-view basis.  Of course, transformation technologies
					are pluggable and you can easily define your own.
				</para>
				<para>
					In addition you can halt the transformation process at any point
					and output the intermediate content.  If you're using XSLT, this
					is a great way to produce static XML and build your templates
					offline with standard tools. 
				</para>
			</listitem>
			<listitem>
				<para>
					Your commands, controllers, views, and transforms are configured
					with an easy-to-understand XML sitemap.  For even more flexibility,
					you can preprocess it with XSLT.
				</para>
			</listitem>
			<listitem>
				<para>
					Maverick will automagically pick from different views based
					on user language, browser type, or any other characteristic
					of the request.  Of course, this behavior is pluggable.
				</para>
			</listitem>
			<listitem>
				<para>
					Maverick supports both Struts-style singleton Controllers
					(aka Actions) and Webwork-style "throwaway" Controllers.
				</para>
			</listitem>
			<listitem>
				<para>
					Maverick is multi-platform; it has been ported to both
					<ulink url="http://mavnet.sourceforge.net">.NET</ulink> and
					<ulink url="http://amb.sourceforge.net">PHP</ulink>.
				</para>
			</listitem>
		</itemizedlist>

		<para>
			Depending on what templating technology you choose, you
			may be interested in one or more of the following features:
		</para>

		<itemizedlist spacing="compact">
			<listitem>
				<para>
					Maverick can automatically "domify" (or "saxify") arbitrary Java
					objects so that XSLT can be used without the effort and processing
					overhead of generating and parsing text XML.  XSLT can be used
					as a templating language directly on your model just like JSP.
				</para>
			</listitem>
			<listitem>
				<para>
					For text-based templating engines like JSP or Velocity, an elegant
					way to apply a common "look and feel" and layout to a set of views
					is to use the "wrapping" transformation.  The output of the previous
					step is made available to subsequent steps as a String variable
					which can be placed anywhere on the page.
				</para>
			</listitem>
			<listitem>
				<para>
					FOP transformations allow your application to produce PDF,
					Postscript, PCL, and a half-dozen other document formats
					on-the-fly.
				</para>
			</listitem>
			<listitem>
				<para>
					An interesting alternative to XSLT is DVSL.  This is a declarative
					templating language patterned after XSLT but based on Velocity.
				</para>
			</listitem>
		</itemizedlist>

        <para>
			If you like Maverick, but also would like to use additional features like
    		Webwork and Struts provide, you might want to check out 
    		<ulink url="http://baritus.sourceforge.net">Baritus</ulink>. Baritus
    		is an extension of Maverick that provides a boosted version of the
    		FormBeanUser controller. It focusses on fine grained population,
    		validation and error reporting, has several utilities for things like
    		formatting output and supports the concept of interceptors.
        </para>
		<para>
			This is not a framework designed by people who build frameworks; Maverick
			is designed and built by people who build web applications for a living
			and were disappointed with the complexity and invasiveness of existing
			open source tools.
		</para>
	</preface>
	
	<chapter>
		<title>Concepts</title>
		
		<section>
			<title>What means MVC?</title>
			
			<para>
				An excellent quick introduction of MVC aka "Model 2" concepts
				can be found
				<ulink url="http://developer.java.sun.com/developer/onlineTraining/JSPIntro/contents.html#JSPIntro4">here</ulink>.
			</para>
		</section>
		
		<section>
			<title>Command Processing Overview</title>
			
			<para>
				This is a short explanation of how Maverick (and your web application)
				processes requests.  A detailed explanation can be found in a later
				chapter.
			</para>
			
			<para>
				Maverick processes commands that are mapped to the Dispatcher servlet
				through extension mapping.  For example, all URIs which end with *.m
				can be mapped to Maverick.  The URI, minus the webapp context and
				the extension is the command.  For example, lets say you have a
				webapp mounted on <filename>/foo</filename> and a request comes in for
				<filename>http://your.site.com/foo/runQuery.m</filename>.  The command
				is "runQuery".
			</para>
			
			<para>
				What Maverick does with a command is determined by the Maverick
				configuration file.  Here is a complete (albeit simple) example:
			</para>

			<programlisting>
<![CDATA[<maverick version="2.0">
  <commands>
    <command name="runQuery">
      <controller class="com.bar.foo.Query"/>
      <view name="success" type="document" path="queryResult.jsp">
        <transform type="xslt" path="lookAndFeel.xsl"/>
      </view>
      <view name="error" type="document" path="queryFailed.jsp">
        <transform type="xslt" path="lookAndFeel.xsl"/>
      </view>
    </command>
  </commands>
</maverick>]]>
			</programlisting>
			
			<para>
				This file defines a single command, <filename>runQuery</filename>,
				which has two possible outcomes (views):  "success" and
				"error".
			</para>
			
			<para>
				When the <filename>runQuery</filename> command is requested, the
				following steps occur:
			</para>
			
			<orderedlist>
				<listitem>
					<para>
						An instance of the controller class
						<classname>com.bar.foo.Query</classname> is created.
						<footnote>
							<para>
								It is also possible to have singleton controllers with
								form beans similar to Struts.
							</para>
						</footnote>
					</para>
				</listitem>
				<listitem>
					<para>
						The <function>perform()</function> method on the controller
						is called.  Depending on the type
						of controller used, this may result in bean properties of the
						controller being populated with the http request parameters
						prior to execution application logic.
					</para>
				</listitem>
				<listitem>
					<para>
						During execution, the <function>perform()</function> method
						can define an object which will be used as the model.
					</para>
				</listitem>
				<listitem>
					<para>
						The return value from
						<function>perform()</function> specifies the name of
						the view to render.  This example will assume "success".
					</para>
				</listitem>
				<listitem>
					<para>
						The model is placed in the servlet request attributes with the
						key "model".
					</para>
				</listitem>
				<listitem>
					<para>
						The JSP page <filename>queryResult.jsp</filename> is executed,
						which uses the model to generate XML.
					</para>
				</listitem>
				<listitem>
					<para>
						The XML is transformed with the XSLT file
						<filename>lookAndFeel.xsl</filename>, which applies the title
						bar, navigation bar, and footer.  The result is sent back
						to the client.
					</para>
				</listitem>
			</orderedlist>

			<para>
				There are many other possible configurations, including other types
				of views (for instance, redirects) and other types of transforms
				(including "wrapping" transforms and DVSL).  Transforms themselves
				are unnecessary.  Furthermore, it is possible to define controllers
				in a variety of ways.  Just about every aspect of Maverick is
				pluggable and configurable.
			</para>
		</section>
	</chapter>
	
	<chapter>
		<title>Using Maverick</title>
		
		<para>
			Maverick includes many example applications which illustrate how to
			set up a basic web application.  It would be helpful to examine them
			as you go through this documentation.
		</para>
		
		<section>
			<title>Configuring web.xml</title>
			
			<para>
				The first step in building a Maverick application is to configure the
				Dispatcher servlet in your web.xml.  All commands with a
				particular extention, say "*.m", are mapped to this servlet:
			</para>
			
			<programlisting>
<![CDATA[<web-app>
  <display-name>Friendbook Web Application</display-name>
	
  <servlet>
    <servlet-name>dispatcher</servlet-name>
    <display-name>Maverick Dispatcher</display-name>
    <servlet-class>org.infohazard.maverick.Dispatcher</servlet-class>
    <load-on-startup>2</load-on-startup>
  </servlet>

  <servlet-mapping>
    <servlet-name>dispatcher</servlet-name>
    <url-pattern>*.m</url-pattern>
  </servlet-mapping>
</web-app>]]>
			</programlisting>
			
			<para>
				There are several init-parameters for the Dispatcher:
			</para>
	
			<formalpara>
				<title>configFile</title>
				<para>
					The path to the maverick XML config file.  If not specified, this
					defaults to <filename>/WEB-INF/maverick.xml</filename>.  Can be overriden
					by setting an application-context attribute with the key
					Dispatcher.KEY_CONFIG_FILE.
				</para>
			</formalpara>
			
			<formalpara>
				<title>configTransform</title>
				<para>
					Path to an XSL file which is used to transform the Maverick
					configuration file prior to loading.  If left unspecified, no
					transformation is executed.  Can be overriden
					by setting an application-context attribute with the key
					Dispatcher.KEY_CONFIG_TRANSFORM.
				</para>
			</formalpara>
			
			<formalpara>
				<title>currentConfigCommand</title>
				<para>
					If defined, this command outputs the current configuration
					XML, including any transformation specified by the
					<parameter>configTransform</parameter>.  If you have sensitive
					information in your config file, be sure to disable this
					command on your production system.
				</para>
			</formalpara>

			<formalpara>
				<title>reloadCommand</title>
				<para>
					If defined, this command causes Maverick to reload the configuration file
					and all associated cached data (templates, etc).  This does not stop
					Maverick from servicing commands; execution continues with the old
					configuration until the new data is completely loaded and ready.  Because
					this operation is processor intensive, you probably want to disable it
					(leave it undefined) or name it something obscure on a production system. 
				</para>
			</formalpara>
			
			<formalpara>
				<title>limitTransformsParam</title>
				<para>
					If defined, this specifies the name of a special request query
					parameter which, when added to a request, limits the number of
					transforms which will be applied.  This allows any page rendering
					to be halted midstream and the intermediate result sent to the
					browser.
				</para>
			</formalpara>
			
			<formalpara>
				<title>defaultRequestCharset</title>
				<para>
					This allows web applications to override the charset used to decode HTTP
					request parameters.
					<footnote>
						<para>
							In general, browsers encode submissions using the
							same charset used to encode the document which contains the form.
							However, this bit of information (the encoding charset) is *not* sent
							along with the HTTP request by any existing browsers, so the
							server has to guess at what charset to use to decode the submission. 
						</para>
						<para>
							In fact, that "guess" usually (for Tomcat and Orion, at least) means
							that web containers default to ISO-8859-1 unless the servlet
							specifically calls HttpServletRequest.setCharacterEncoding() *before*
							any data is read, including accessing any of the parameters.  Some web
							containers offer other strategies (like guessing based on the user's
							locale, which *is* submitted), but they all have serious problems (like
							does jp mean Kanji or UTF-8?).
						</para>
						<para>
							Specifying a <emphasis>defaultRequestCharset</emphasis> causes
							HttpServletRequest.setCharacterEncoding() to be called.  When
							building internationalized applications, you will probably be best
							off if you pick a charset which accomodates all your languages
							(like UTF-8) and sticking to it religiously.
						</para>
					</footnote>
					If not defined, the servlet container's default (typically ISO-8859-1) is
					used.
				</para>
			</formalpara>
			
			<formalpara>
				<title>reuseMaverickContext</title>
				<para>
					If set to "true", the Maverick context object will be persisted
					through multiple Maverick invocations within the same request.
					This may be useful for chaining several command invocations by
					forwarding (with a document view) to a maverick command.  Because
					this causes problems with SiteMesh, the default is false.
				</para>
			</formalpara>
		</section>
		
		<section>
			<title>Configuring maverick.xml</title>
			
			<para>
				The heart of a Maverick application is the <filename>maverick.xml</filename>
				file.  This file contains all the information about what commands are
				available, what code (controllers) are associated with specific commands,
				and what views can result from a command.
			</para>
			
			<para>
				By default, this file resides in your web application as
				<filename>WEB-INF/maverick.xml</filename>.  The location is
				configurable as a an init-param to the
				<classname>Dispatcher</classname> servlet.
			</para>
			
			<para>
				The schema of the configuration file is quite flexible because
				much of it is interpreted by pluggable modules.  Each of the view
				types and transform types are defined by instances of special
				factory classes which can be configured in the <sgmltag>modules</sgmltag>
				element.  The documentation for individual view or transform types
				is found in the javadocs for the factory.
			</para>

			<para>
				By way of convention, the following constructs are usually
				considered equivalent and can be used interchangably:
			</para>
			
			<itemizedlist>
				<listitem>
					<para><markup><![CDATA[<element attr="blah"/>]]></markup></para>
				</listitem>
				<listitem>
					<para><markup><![CDATA[<element><attr value="blah"/></element>]]></markup></para>
				</listitem>
			</itemizedlist>
			
			<para>
				In addition, these flexible elements can also be overriden
				by a system property.  The example above can be overriden
				with a property constructed like this:
				<parameter>maverick.element.attr</parameter>.  An example
				argument to the java command like would be:
				<command>-Dmaverick.element.attr=overrideblah</command>
			</para>
			
			<para>
				See the appendix for an explanation of the options available
				in the Maverick configuration file.
			</para>
		</section>
	</chapter>
	
	<chapter>
		<title>Templating Technologies</title>
		
		<section>
			<title>JSP</title>
			
			<para>
				Using JSP with Maverick is straightforward.  Use the "document"
				view type to reference your JSP documents.  The model will be
				placed in the servlet request attribute collection so that your
				JSP can access it.  The default key is "model", but both the
				default and individual view keys can be configured.  Params 
				(either defined with <sgmltag>param</sgmltag> elements in the
				config file or defined by your application calling
				<function>ControllerContext.setParam()</function>)
				are also placed in the request context.
			</para>
			<para>
				Document views allow transforms.  The friendbook-jsp sample
				application demonstrates the use of "document" transforms,
				which provides content from previous steps to subsequent
				steps in the form of a String in the servlet request
				attribute collection.
			</para>
		</section>
		
		<section>
			<title>XSLT</title>
			
			<para>
				There are several ways of working with XSLT in Maverick.
				XSLT itself is available as a transform type, not a view.
				This means you can apply XSLT transformation to any view
				type that supports transforms.
			</para>
			<para>
				The traditional way is to use document views such as JSP
				to generate text XML which will then be transformed.
				This works just fine, but it is cumbersome and adds
				a significant amount of processing overhead.
			</para>
			<para>
				A much more elegant mechanism is included in Maverick's
				opt-domify package.  Rather than using a templating language
				to generate textual XML from the model, Domify uses Java
				reflection to automagically adapt the model to a DOM facade.
				The "domify" view type wraps the model with a Domify adapter
				and then hands the DOM source off to the transform.  The DOM
				tree is lazy-loaded for efficiency; the tree is built as the
				processor navigates the DOM.
			</para>
			<para>
				This approach is not only more efficient (no need to generate
				or parse XML), but it allows designers to work immediately
				with XSLT as a templating language.  Since Maverick's XSLT
				transform allows the transformation process to be halted at
				any step, it is easy to obtain the raw XML so that designers
				can work offline.
			</para>
			<para>
				The opt-domify package contains a domify version of the
				friendbook sample application.  The controller classes are
				the same as those used for friendbook-jsp; only the
				<filename>maverick.xml</filename> and the templates are
				different.
			</para>
			<para>
				Domify was created for Maverick, but it has been spun off
				into a 
				<ulink url="http://domify.sourceforge.net">separate sourceforge
				project</ulink>.  Development continues there.
			</para>
		</section>
		
		<section>
			<title>Velocity</title>
			
			<para>
				In most ways, using Velocity with Maverick is just like
				using JSP.  Thanks to the Jakarta Struts integration effort,
				the Velocity folks have produced a
				<classname>VelocityViewServlet</classname> which allows your
				web container to handle Velocity templates in the same way
				that your web container handles JSP templates.  All requests
				for Velocity files (*.vm) are mapped to this servlet, which
				masquerades the servlet attribute collections as the
				Velocity <classname>Context</classname>.
			</para>
			<para>
				To use Maverick with Velocity, simply register the
				<classname>VelocityViewServlet</classname> in your
				<filename>web.xml</filename> deployment descriptor
				and then use the normal Maverick "document" view type.
				The model will be available in the context with the
				key "model" (just as with JSP, this is configurable).
				You can also use any type of transform with these views,
				including "document" transforms.  You can use Velocity
				to write these "document" transforms.
			</para>
			<para>
				The opt-velocity package is not necessary to use Velocity
				with Maverick, however it does provide some assistance.
				It includes a version of the friendbook sample application
				which uses Velocity.  It includes a recent version of the
				VelocityViewServlet.  It also includes a new transform
				type based on the experimental DVSL technology recently
				developed by the Velocity team.
			</para>
			<para>
				DVSL is a technology very similar in form and purpose to
				XSLT.  It is a declarative, "matching" language with a
				syntax based on XSLT but which uses Velocity to generate
				output.  This carries with it a number of advantages and
				disadvantages that are out of scope for this document.
			</para>
		</section>
	</chapter>

	<chapter>
		<title>Internationalization and Shunting</title>
		
		<para>
			There are many, many ways to internationalize a web application,
			many of which are dependent on the specific templating language
			you are using.  Nevertheless, Maverick offers considerable
			assistance with this task in a way which is useful for performing
			other kinds of "view customization", such as providing
			browser-specific behavior or delivering WML.
		</para>
		<para>
			The two important concepts that Maverick adds are "modes"
			and "shunts".  Modes allow you to define multiple views with
			the same name.  Shunts are pluggable Maverick modules that
			determine at runtime which view's mode should be executed.
		</para>
		<para>
			You can set up a Maverick application to use shunts by configuring
			a <sgmltag>shunt-factory</sgmltag> in the <sgmltag>modules</sgmltag>
			section.  The factory will be used to create a
			<classname>Shunt</classname> for each named view.  Here is a
			simple example of a Maverick application that uses the
			<classname>org.infohazard.maverick.shunt.LanguageShuntFactory</classname>:
		</para>
		<programlisting>
<![CDATA[<maverick version="2.0" default-view-type="document">
  <modules>
    <shunt-factory provider="org.infohazard.maverick.shunt.LanguageShuntFactory"/>
  </modules>
  
  <commands>
    <command name="runQuery">
      <controller class="org.foo.Query"/>
      
      <view name="success" path="en/queryResults.jsp"/>
      <view name="success" mode="fr" path="fr/queryResults.jsp"/>
      <view name="success" mode="de" path="de/queryResults.jsp"/>
      
      <view name="error" path="en/queryError.jsp"/>
      <view name="error" mode="fr" path="fr/queryError.jsp"/>
      <view name="error" mode="de" path="de/queryError.jsp"/>
    </command>
  </commands>
</maverick>]]>
		</programlisting>
		<para>
			The <classname>LanguageShuntFactory</classname> builds shunts
			which determine mode based on the value of the
			<parameter>Accept-Language</parameter> header of the HTTP request.
			Your controller (<classname>org.foo.Query</classname>) determines
			which view name to render; the shunt determines which mode
			should be used.
		</para>
		<para>
			Currently, Maverick provides only the
			<classname>LanguageShuntFactory</classname>,
			but the <classname>Shunt</classname> and
			<classname>ShuntFactory</classname> interfaces are very simple
			so it is easy to implement your own.  You can use this facility
			to perform automatic customization based on browser, or to
			offer WML content to WAP devices.
		</para>
	</chapter>
	
	<chapter>
		<title>Optional Packages</title>
		
		<para>
			Maverick is an extendable framework, and many features are implemented
			as pluggable modules.  Here is an overview of the various packages
			available for download on the Maverick website:
		</para>
		
		<section>
			<title>opt-domify</title>
			<para>
				<ulink url="http://domify.sourceforge.net">Domify</ulink> is a
				Java library that adapts arbitrary JavaBeans (and collections) to a W3C DOM
				representation.  It was originally created as part of Maverick but has
				since been separated out into a separate project.  
			</para>
			<para>
				This optional package includes a Maverick view type for "domify" views
				and a version of the Friendbook sample application which uses Domify
				and XSLT for presentation.
			</para>
		</section>
		
		<section>
			<title>opt-betwixt</title>
			<para>
				<ulink url="http://jakarta.apache.org/commons/betwixt/">Betwixt</ulink> 
				is an alternative to Domify.  It can generate a series of
				SAX events from a JavaBean model.
			</para>
			<para>
				Note that this option is less well tested than Domify.
			</para>
		</section>

		<section>
			<title>opt-fop</title>
			<para>
				Apache <ulink url="http://xml.apache.org/fop/">FOP</ulink>
				is a processor that can transform XSL-FO (formatting objects)
				into a variety of presentation formats, including PDF and Postscript.
				The opt-fop package provides FOP services as a Maverick transform type.
			</para>
			<para>
				For example, you can use XSLT to transform your model into XSL-FO,
				then use the FOP transform to emit PDF back to the user.
			</para>
		</section>

		<section>
			<title>opt-velocity</title>
			<para>
				Using <ulink url="http://jakarta.apache.org/velocity/">Velocity</ulink>
				with Maverick does not require a new view type.  Instead,
				normal "document" views are used in conjunction with the
				<classname>VelocityViewServlet</classname> that was originally developed
				for Struts.  Using Velocity with Maverick is very much like using JSP.
			</para>
			<para>
				This package includes three things:
			</para>
			<itemizedlist>
				<listitem>
					A relatively recent build of VelocityViewServlet.
				</listitem>
				<listitem>
					A Velocity version of the Friendbook sample application.
				</listitem>
				<listitem>
					A Maverick transform type for DVSL.  DVSL is an experimental
					XML transformation language patterned after XSLT but based on
					Velocity.
				</listitem>
			</itemizedlist>
		</section>
		
		<section>
			<title>opt-perl</title>
			<para>
				Offers a Maverick transform type that runs output through
				Perl.
			</para>
		</section>
		
		<section>
			<title>opt-struts</title>
			<para>
				Provides a number of tools to help you migrate a Struts application
				to Maverick.
			</para>
		</section>
</chapter>

	<chapter>
		<title>How Maverick Works</title>
		
		<para>
			There are two basic phases in the life of an executing Maverick
			application.  The first is the "load" phase which (usually)
			occurs once and uses the config file to construct a tree of
			<emphasis>workflow</emphasis> objects.  The second is the
			"execution" phase in which http requests are serviced.  Maverick
			is designed to perform as much work as possible during the
			load phase so that the execution phase can be as fast as possible.
		</para>
		<para>
			The workflow tree constructed during the load phase represents
			all of the possible execution paths for servicing an http request.
			It consists of objects which implement various interfaces, and
			many of the objects are created by pluggable factories.  After
			the workflow tree is built, the overhead Maverick itself adds
			to a running web application should be little more than a couple
			Map lookups and a handful of virtual method calls.
		</para>
		<para>
			The top level object is a <classname>Command</classname> object,
			which corresponds to a single defined command in the config file.
			Other than special implementations like the reload command, there
			are two basic implementations of the <classname>Command</classname>
			interface:  <classname>CommandSingleView</classname> and
			<classname>CommandMultipleViews</classname>.  The
			<classname>CommandFactory</classname> will automatically build
			the correct instance depending on how many views are available;
			the only difference is that <classname>CommandSingleView</classname>
			can eschew the <classname>Map</classname> lookup to deterimine
			which view to render.
		</para>
		<para>
			There is always one <classname>Controller</classname> associated
			with every command; a simple null controller is generated by the
			<classname>ControllerFactory</classname> when no controller is
			specified by the user.  In addition, it should be noted that
			from the perspective of the command objects, controllers always
			look like singleton controllers; a special
			<classname>ThrowawayAdapter</classname> is used for "normal"
			controllers.
		</para>
		<para>
			The command object chooses a <classname>View</classname> to render.
			Views are built by the flexible <classname>ViewFactory</classname>
			system.  At runtime, execution passes from the
			<classname>Command</classname> to the <classname>View</classname>
			identified by the <function>Controller.go()</function> return
			value; the <classname>View</classname> is responsible for "dealing
			with" the request from here out.  There are many types of views.
		</para>
		<para>
			If a <classname>ShuntFactory</classname> was defined in the
			<sgmltag>modules</sgmltag> part of the config file, the
			<sgmltag>View</sgmltag> instances held by a
			<classname>Command</classname> will actually be instances
			of the decorator <classname>ViewShunted</classname>, which
			holds a <classname>Map</classname> of real views and adds the
			mode switching behavior.
		</para>
		<para>
			Actual <classname>View</classname> implementations are responsible
			for tasks like sending HTTP redirects, or rendering the model
			using a JSP page.  Output is rendered through a
			<classname>TransformStep</classname>
			object obtained from the <classname>ViewContext</classname>
			passed into <function>go()</function>.  Depending on the
			configuration in <filename>maverick.xml</filename>, the
			<classname>TransformStep</classname> may be the entry point
			for a sequence of transformations or it may actually dump the
			results directly to the response output stream.
		</para>
		<para>
			Thus, at execution time, an HTTP request is serviced like this:
		</para>
		<orderedlist>
			<listitem>
				<para>
					The <classname>Dispatcher</classname> receives the request
					and looks in a <classname>Map</classname> for the
					<classname>Command</classname> associated
					with the particular URL.  <function>Command.go()</function>
					is called.
				</para>
			</listitem>
			<listitem>
				<para>
					The <classname>Command</classname> calls
					<function>Controller.go()</function>.  The 
					controller optionally sets the model object
					(using a method on <classname>ControllerContext</classname>)
					and returns a String indicating the name of the
					view to render.
				</para>
			</listitem>
			<listitem>
				<para>
					The <classname>Command</classname> looks in a
					<classname>Map</classname> for the
					<classname>View</classname> to render.
					<function>View.go()</function> is called and passed
					a <classname>ViewContxt</classname> object.
				</para>
			</listitem>
			<listitem>
				<para>
					If shunting was enabled, the <classname>View</classname>
					will actually be an instance of
					<classname>ViewShunted</classname>.  This object uses
					the <classname>Shunt</classname> to find the actual
					view to render; the actual mechanism for this is specific
					to the shunt.
				</para>
			</listitem>
			<listitem>
				<para>
					The <classname>View</classname> generates some content and
					sends it to the <classname>TransformStep</classname> obtained
					from <function>ViewContext.getNextStep()</function>.  If there
					were no transforms defined, this step will actually be
					a special implementation that sends output directly to the
					real response.
				</para>
			</listitem>
			<listitem>
				<para>
					<classname>TransformStep</classname> objects are chained
					together such that one passes information to the next.
					Eventually the data gets passed to the special implementation
					which sends output to the real response.
				</para>
			</listitem>
		</orderedlist>
	</chapter>

	<chapter>
		<title>Extending Maverick</title>
		
		<para>
			Maverick was designed with pluggability and extendability
			in mind.  There are normally four ways of extending Maverick:
			custom view factories, custom transform factories, custom
			shunt factories, and custom controllers.  Maverick itself
			uses these mechanisms to provide the base functionality.
		</para>
		
		<section>
			<title>Custom View Types</title>
			<para>
				Anyone can add a custom view type to Maverick by plugging
				in their own implementation of
				<classname>org.infohazard.maverick.flow.ViewFactory</classname>.
				If a Maverick config file defines the factory as a
				<sgmltag>view-factory</sgmltag> in the
				<sgmltag>modules</sgmltag> section, the factory object
				will be created and initialized with the XML which
				defined the factory.  This way child elements and
				attributes can be used to configure the factory.
			</para>
			<para>
				When processing the configuration file, Maverick identifies
				which factory to use to generate <classname>View</classname>
				objects based on the <sgmltag>type</sgmltag> attribute.
				The factory is then asked to create a <sgmltag>View</sgmltag>
				instance based on the snippet of XML which defined the
				view.
			</para>
		</section>
		<section>
			<title>Custom Transform Types</title>
			
			<para>
				Creating a custom <classname>TransformFactory</classname>
				is nearly identical to creating a custom
				<classname>ViewFactory</classname>.  The framework
				automatically recognizes <sgmltag>transform</sgmltag>
				elements within <sgmltag>view</sgmltag> elements and
				builds the appropriate <classname>Transform</classname>
				chain.
			</para>
		</section>
		<!--
		<section>
			<title>Custom Shunt Factories</title>
			<para>TODO</para>
		</section>
		<section>
			<title>Custom Controllers</title>
			<para>TODO</para>
		</section>
		-->
	</chapter>

	<chapter>
		<title>More Information</title>
		
		<para>
			Maverick is hosted by SourceForge.  For updated information, visit
			the <ulink url="http://mav.sourceforge.net">website</ulink> or the
			<ulink url="http://sourceforge.net/projects/mav">project page</ulink>.
		</para>
		
		<para>
			Downloads are available
			<ulink url="http://sourceforge.net/project/showfiles.php?group_id=26951">here</ulink>.
		</para>
		
		<para>
			For help using Maverick and discussion of the future direction of Maverick,
			subscribe to the
			<ulink url="http://lists.sourceforge.net/lists/listinfo/mav-user">mav-user</ulink>
			mailing list.
		</para>
		
		<para>
			For a comprehensive sample J2EE application built with Maverick, XSLT, and EJBs,
			examine the <ulink url="http://mav.sourceforge.net/pig">Punk Image
			Gallery</ulink>.
		</para>
		
		<para>
			For more information about Domify, visit the
			<ulink url="http://domify.sourceforge.net">domify</ulink> home page.
		</para>

		<para>
			For more information about Velocity, visit the
			<ulink url="http://jakarta.apache.org/velocity">velocity</ulink> page
			at the jakarta apache project.
		</para>
		
		<para>
			For more information about the Maverick extension Baritus, visit the
			<ulink url="http://baritus.sourceforge.net">Baritus</ulink> home page.
		</para>
	</chapter>
	
	<chapter>
		<title>Credits</title>
		
		<para>
			Maverick is an Open Source project distributed with an Apache-style
			license.  It was created by Jeff Schnitzer and Scott Hernandez.
			The first public release was 17 May 2001.
		</para>
		
		<para>
			The Maverick logo is courtesy of Mike Moulton and the talented artists at
			<ulink url="http://www.meltmedia.com"/>.
		</para>
		
		<para>
			This product includes software developed by the
			Apache Software Foundation
			(<ulink url="http://www.apache.org">http://www.apache.org/</ulink>).
		</para>
	</chapter>

	<appendix>
		<title>Configuration Schema Reference</title>
		
		<refentry>
			<refnamediv>
				<refname>maverick</refname>
				<refpurpose>
					The root element of Maverick configuration
				</refpurpose>
			</refnamediv>
			<refsynopsisdiv>
				<title>Synopsis</title>
				<refsect2>
					<title>Content</title>
					<para>
						maverick ::= (modules?, views*, commands+)
					</para>
				</refsect2>
				<refsect2>
					<title>Attributes</title>
					<informaltable frame="all">
						<tgroup cols="3">
							<thead>
								<row>
									<entry>Name</entry>
									<entry>Type</entry>
									<entry>Default</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>version</entry>
									<entry>CDATA</entry>
									<entry><emphasis>Required</emphasis>.  Must be "2.0"</entry>
								</row>
								<row>
									<entry>default-view-type</entry>
									<entry>CDATA</entry>
									<entry>
										"document".
									</entry>
								</row>
								<row>
									<entry>default-transform-type</entry>
									<entry>CDATA</entry>
									<entry>
										"document".
									</entry>
								</row>
							</tbody>
						</tgroup>
					</informaltable>
				</refsect2>
			</refsynopsisdiv>
			<refsect1>
				<title>Descripton</title>
				<para>
					<sgmltag>maverick</sgmltag> is the root element of Maverick
					configuration.  It contains everything.
				</para>
			</refsect1>
			<refsect1>
				<title>Attributes</title>
				<formalpara>
					<title>version</title>
					<para>The version of the schema.  Must be 2.0.</para>
				</formalpara>
				<formalpara>
					<title>default-view-type</title>
					<para>
						The assumed type of <sgmltag>view</sgmltag> nodes which
						do not have an explicit <sgmltag>type</sgmltag> attribute.
					</para>
				</formalpara>
				<formalpara>
					<title>default-transform-type</title>
					<para>
						The assumed type of <sgmltag>transform</sgmltag> nodes which
						do not have an explicit <sgmltag>type</sgmltag> attribute.
					</para>
				</formalpara>
			</refsect1>
			<refsect1>
				<title>Examples</title>
				<programlisting>
<![CDATA[<maverick version="2.0" default-view-type="document" default-transform-type="xslt">
  <modules>
    ...
  </modules>
  <views>
    ...
  </views>
  <commands>
    ...
  </commands>
</maverick>]]>
				</programlisting>
			</refsect1>
		</refentry>
		
		<refentry>
			<refnamediv>
				<refname>modules</refname>
				<refpurpose>
					Contains entries for pluggable modules.
				</refpurpose>
			</refnamediv>
			<refsynopsisdiv>
				<title>Synopsis</title>
				<refsect2>
					<title>Content</title>
					<para>
						modules ::= (view-factory*, transform-factory*, shunt-factory?)
					</para>
				</refsect2>
				<refsect2>
					<title>Attributes</title>
					<para>None</para>
				</refsect2>
			</refsynopsisdiv>
			<refsect1>
				<title>Descripton</title>
				<para>
					The <sgmltag>modules</sgmltag> element acts as a container
					for pluggable Maverick modules, such as view factories and
					transform factories.  It is otherwise unremarkable.
				</para>
			</refsect1>
			<refsect1>
				<title>Attributes</title>
				<para>None</para>
			</refsect1>
			<refsect1>
				<title>Examples</title>
				<programlisting>
<![CDATA[<maverick version="2.0" default-view-type="domify" default-transform-type="xslt">
  <modules>
    <view-factory type="domify" provider="org.infohazard.maverick.opt.view.DomifyViewFactory/>
    <transform-factory type="dvsl" provider="org.infohazard.maverick.opt.transform.DVSLTransformFactory/>
    <transform-factory type="xslt" provider="org.infohazard.maverick.transform.XSLTransformFactory>
      <lazy-load-templates value="true"/>
    </transform-factory>
    <shunt-factory provider="org.infohazard.maverick.shunt.LanguageShuntFactory"/>
    <controller-factory provider="org.infohazard.maverick.flow.DefaultControllerFactory">
  </modules>
  
  ...
</maverick>]]>
				</programlisting>
			</refsect1>
		</refentry>

		<refentry>
			<refnamediv>
				<refname>view-factory</refname>
				<refpurpose>
					Configures a pluggable view type
				</refpurpose>
			</refnamediv>
			<refsynopsisdiv>
				<title>Synopsis</title>
				<refsect2>
					<title>Content</title>
					<para>
						view-factory ::= <emphasis>[Special]</emphasis>
					</para>
				</refsect2>
				<refsect2>
					<title>Attributes</title>
					<informaltable frame="all">
						<tgroup cols="3">
							<thead>
								<row>
									<entry>Name</entry>
									<entry>Type</entry>
									<entry>Default</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>type</entry>
									<entry>CDATA</entry>
									<entry><emphasis>Required</emphasis></entry>
								</row>
								<row>
									<entry>provider</entry>
									<entry>CDATA</entry>
									<entry><emphasis>Required</emphasis></entry>
								</row>
							</tbody>
						</tgroup>
					</informaltable>
				</refsect2>
			</refsynopsisdiv>
			<refsect1>
				<title>Descripton</title>
				<para>
					A <sgmltag>view-factory</sgmltag> is a pluggable module which
					defines a particular presentation scheme.  These factories
					build the Maverick workflow tree which processes requests
					at runtime.  Examples include the "redirect", "document",
					"trivial", and "null" view factories.
				</para>
				<para>
					View factory classes must implement the
					<classname>org.infohazard.maverick.flow.ViewFactory</classname>
					interface.  The factory instance will be passed the XML
					fragment of the <sgmltag>view-factory</sgmltag> element
					and is free to interpret the XML in any manner.  Thus,
					full documentation for what are the allowable contents
					of a <sgmltag>view-factory</sgmltag> element can be found
					by examining the javadocs of the particular factory being
					instantiated.
				</para>
				<para>
					Note that it is possible to override the base view factories
					by explicitly defining them.  This is useful for altering
					the default parameters of a particular view type.
				</para>
			</refsect1>
			<refsect1>
				<title>Attributes</title>
				<formalpara>
					<title>type</title>
					<para>
						The unique key for this view type, to be used as the
						<sgmltag>type</sgmltag> attribute of <sgmltag>view</sgmltag>
						elements.  A duplicate will override the previous
						factory.
					</para>
				</formalpara>
				<formalpara>
					<title>provider</title>
					<para>
						The full classname of a class that implements
						<classname>org.infohazard.maverick.flow.ViewFactory</classname>.
					</para>
				</formalpara>
			</refsect1>
			<refsect1>
				<title>Examples</title>
				<para>
					See <sgmltag>modules</sgmltag>.
				</para>
			</refsect1>
		</refentry>

		<refentry>
			<refnamediv>
				<refname>transform-factory</refname>
				<refpurpose>
					Configures a pluggable transform type
				</refpurpose>
			</refnamediv>
			<refsynopsisdiv>
				<title>Synopsis</title>
				<refsect2>
					<title>Content</title>
					<para>
						transform-factory ::= <emphasis>[Special]</emphasis>
					</para>
				</refsect2>
				<refsect2>
					<title>Attributes</title>
					<informaltable frame="all">
						<tgroup cols="3">
							<thead>
								<row>
									<entry>Name</entry>
									<entry>Type</entry>
									<entry>Default</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>type</entry>
									<entry>CDATA</entry>
									<entry><emphasis>Required</emphasis></entry>
								</row>
								<row>
									<entry>provider</entry>
									<entry>CDATA</entry>
									<entry><emphasis>Required</emphasis></entry>
								</row>
							</tbody>
						</tgroup>
					</informaltable>
				</refsect2>
			</refsynopsisdiv>
			<refsect1>
				<title>Descripton</title>
				<para>
					A <sgmltag>transform-factory</sgmltag> is a pluggable module which
					allows content from a view to be manipulated in some way.  These
					factories build the Maverick workflow tree which processes requests
					at runtime.  The word "transform" is commonly associated with XSLT,
					but Maverick allows many other types, including DVSL (similar to
					XSLT but uses Velocity), "wrapping" transforms, and FOP.
				</para>
				<para>
					Transform factory classes must implement the
					<classname>org.infohazard.maverick.flow.TransformFactory</classname>
					interface.  The factory instance will be passed the XML
					fragment of the <sgmltag>transform-factory</sgmltag> element
					and is free to interpret the XML in any manner.  Thus,
					full documentation for what are the allowable contents
					of a <sgmltag>transform-factory</sgmltag> element can be found
					by examining the javadocs of the particular factory being
					instantiated.
				</para>
				<para>
					Note that it is possible to override the base transform factories
					by explicitly defining them.  This is useful for altering
					the default parameters of a particular transform type.
				</para>
			</refsect1>
			<refsect1>
				<title>Attributes</title>
				<formalpara>
					<title>type</title>
					<para>
						The unique key for this transform type, to be used as the
						<sgmltag>type</sgmltag> attribute of <sgmltag>transform</sgmltag>
						elements.  A duplicate will override the previous
						factory.
					</para>
				</formalpara>
				<formalpara>
					<title>provider</title>
					<para>
						The full classname of a class that implements
						<classname>org.infohazard.maverick.flow.TransformFactory</classname>.
					</para>
				</formalpara>
			</refsect1>
			<refsect1>
				<title>Examples</title>
				<para>
					See <sgmltag>modules</sgmltag>.
				</para>
			</refsect1>
		</refentry>

		<refentry>
			<refnamediv>
				<refname>shunt-factory</refname>
				<refpurpose>
					Configures a shunt factory
				</refpurpose>
			</refnamediv>
			<refsynopsisdiv>
				<title>Synopsis</title>
				<refsect2>
					<title>Content</title>
					<para>
						shunt-factory ::= <emphasis>[Special]</emphasis>
					</para>
				</refsect2>
				<refsect2>
					<title>Attributes</title>
					<informaltable frame="all">
						<tgroup cols="3">
							<thead>
								<row>
									<entry>Name</entry>
									<entry>Type</entry>
									<entry>Default</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>provider</entry>
									<entry>CDATA</entry>
									<entry><emphasis>Required</emphasis></entry>
								</row>
							</tbody>
						</tgroup>
					</informaltable>
				</refsect2>
			</refsynopsisdiv>
			<refsect1>
				<title>Descripton</title>
				<para>
					A <sgmltag>shunt-factory</sgmltag> is a pluggable module which
					allows views to be specified with modes.  The Shunt automatically
					chooses the correct mode based on some characteristic of the
					HTTP request.  This is useful for internationalizing an
					application or providing browser-specific behavior.
				</para>
				<para>
					Shunt factory classes must implement the
					<classname>org.infohazard.maverick.flow.ShuntFactory</classname>
					interface.  The factory instance will be passed the XML
					fragment of the <sgmltag>shunt-factory</sgmltag> element
					and is free to interpret the XML in any manner.  Thus,
					full documentation for what are the allowable contents
					of a <sgmltag>shunt-factory</sgmltag> element can be found
					by examining the javadocs of the particular factory being
					instantiated.
				</para>
				<para>
					There can be only one instance of a <sgmltag>shunt-factory</sgmltag>
					defined for a webapp.
				</para>
			</refsect1>
			<refsect1>
				<title>Attributes</title>
				<formalpara>
					<title>provider</title>
					<para>
						The full classname of a class that implements
						<classname>org.infohazard.maverick.flow.ShuntFactory</classname>.
					</para>
				</formalpara>
			</refsect1>
			<refsect1>
				<title>Examples</title>
				<para>
					See <sgmltag>modules</sgmltag>.
				</para>
			</refsect1>
		</refentry>

		<refentry>
			<refnamediv>
				<refname>controller-factory</refname>
				<refpurpose>
					Configures a controller factory
				</refpurpose>
			</refnamediv>
			<refsynopsisdiv>
				<title>Synopsis</title>
				<refsect2>
					<title>Content</title>
					<para>
						controller-factory ::= <emphasis>[Special]</emphasis>
					</para>
				</refsect2>
				<refsect2>
					<title>Attributes</title>
					<informaltable frame="all">
						<tgroup cols="3">
							<thead>
								<row>
									<entry>Name</entry>
									<entry>Type</entry>
									<entry>Default</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>provider</entry>
									<entry>CDATA</entry>
									<entry><emphasis>Required</emphasis></entry>
								</row>
							</tbody>
						</tgroup>
					</informaltable>
				</refsect2>
			</refsynopsisdiv>
			<refsect1>
				<title>Descripton</title>
				<para>
					A <sgmltag>controller-factory</sgmltag> is a pluggable module
					that is responsible for creating the controllers on startup.
				</para>
				<para>
					Controller factory classes must implement the
					<classname>org.infohazard.maverick.flow.ControllerFactory</classname>
					interface.  The factory instance will be passed the XML
					fragment of the <sgmltag>controller-factory</sgmltag> element
					and is free to interpret the XML in any manner.
				</para>
				<para>
					There can be only one instance of a <sgmltag>controller-factory</sgmltag>
					defined for a webapp. If no <sgmltag>controller-factory</sgmltag> is
					defined, the default controller factory
					<classname>org.infohazard.maverick.flow.DefaultControllerFactory</classname>
                    is used.
				</para>
				<para>
				    When providing a custom implementation, it is advisable to extend
				    <classname>org.infohazard.maverick.flow.AbstractControllerFactory</classname>
                    and just override what you need.
				</para>
				<para>
				    Note that in order to provide a custom <sgmltag>controller-factory</sgmltag>,
				    you need to know the Maverick internals to some extend.
				</para>
			</refsect1>
			<refsect1>
				<title>Attributes</title>
				<formalpara>
					<title>provider</title>
					<para>
						The full classname of a class that implements
						<classname>org.infohazard.maverick.flow.ControllerFactory</classname>.
					</para>
				</formalpara>
			</refsect1>
			<refsect1>
				<title>Examples</title>
				<para>
				    A custom controller factory:
				<programlisting>
<![CDATA[
/**
 * Custom implementation of the controller factory that, in case attribute
 * 'allways-reload' is true, creates and initializes a new instance of
 * controllers even if they are of type ControllerSingleton. This can
 * be usefull when testing controllers; eg when you make changes in the init method,
 * you want these changes be loaded while in a production environment, you
 * want the initialization just done once.
 */
public class AllwaysReloadControllerFactory extends AbstractControllerFactory {
    public final static String ATTRIB_ALLWAYS_RELOAD = "allways-reload";
    private boolean allwaysReload = false;
    private static Log log = LogFactory.getLog(AllwaysReloadControllerFactory.class);

    public void init(Element factoryNode, ServletConfig servletCfg) throws ConfigException {
        String allwaysReloadS = XML.getValue(factoryNode, ATTRIB_ALLWAYS_RELOAD);
        if(allwaysReloadS != null) {
            allwaysReload = Boolean.valueOf(allwaysReloadS).booleanValue();
            log.info("allwaysReload set to " + allwaysReload);
        } else {
            log.info("attribute " + ATTRIB_ALLWAYS_RELOAD + " not set");
        }
    }

    protected Controller decorateController(Element controllerNode, Controller controller) throws ConfigException {
        if(allwaysReload) {
            controller = new AllwaysReloadControllerAdapter(controller.getClass());
        }
        // let the framework do any additional decorating (ControllerWithParameters)
        controller = super.decorateController(controllerNode, controller);
        return controller;
    }
}]]>
				</programlisting>
				</para>
				<para>
				    That uses a custom adapter:
				<programlisting>
<![CDATA[
/**
 * This adapter masquerades as a singleton controller but actually
 * creates single-use instance controllers AND initializes the controllers
 * if they are of type ControllerSingleton.
 */
public class AllwaysReloadControllerAdapter implements ControllerSingleton {
	protected Class controllerClass;
	protected Map params = null;
	private Element controllerNode;

	public AllwaysReloadControllerAdapter(Class controllerClass) {
		this.controllerClass = controllerClass;
	}

	public void init(Element controllerNode) throws ConfigException {
	    this.controllerNode = controllerNode;
	}

	public String go(ControllerContext cctx) throws ServletException {
		try {
			Controller instance = (Controller)this.controllerClass.newInstance();
			if(instance instanceof ControllerSingleton) {
			    ((ControllerSingleton)instance).init(controllerNode);
			}
			return instance.go(cctx);
		}
		catch (Exception ex) {
			throw new ServletException(ex);
		}
	}
}]]>
				</programlisting>
				</para>
				<para>
				    Is defined in the maverick configuration document like:
				<programlisting>
<![CDATA[
<maverick version="2.0">
	<modules>
		<controller-factory provider="nl.openedge.util.maverick.CustomControllerFactory">
		    <allways-reload value="true"/>
		</controller-factory>
	</modules>
  
  ...
</maverick>]]>
				</programlisting>
				</para>
			</refsect1>
		</refentry>

		<refentry>
			<refnamediv>
				<refname>views</refname>
				<refpurpose>
					Contains views which can be referenced from any command
				</refpurpose>
			</refnamediv>
			<refsynopsisdiv>
				<title>Synopsis</title>
				<refsect2>
					<title>Content</title>
					<para>
						views ::= (view+)
					</para>
				</refsect2>
				<refsect2>
					<title>Attributes</title>
					<informaltable frame="all">
						<tgroup cols="3">
							<thead>
								<row>
									<entry>Name</entry>
									<entry>Type</entry>
									<entry>Default</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>mode</entry>
									<entry>CDATA</entry>
									<entry>None</entry>
								</row>
							</tbody>
						</tgroup>
					</informaltable>
				</refsect2>
			</refsynopsisdiv>
			<refsect1>
				<title>Descripton</title>
				<para>
					The <sgmltag>views</sgmltag> element acts as a container
					for <sgmltag>view</sgmltag> elements which can be referenced
					from any Maverick command.  All views defined within a
					<sgmltag>views</sgmltag> element <emphasis>must</emphasis>
					use the <sgmltag>id</sgmltag> attribute rather than the
					<sgmltag>name</sgmltag> attribute.
				</para>
			</refsect1>
			<refsect1>
				<title>Attributes</title>
				<formalpara>
					<title>mode</title>
					<para>
						All views contained within the element will be considered
						to have this mode unless an explicit mode is specified on
						the individual <sgmltag>view</sgmltag>.
					</para>
				</formalpara>
			</refsect1>
			<refsect1>
				<title>Examples</title>
				<programlisting>
<![CDATA[<maverick version="2.0">
  <views>
    <view id="loginRequired" path="en/loginRequired.jsp"/>
    <view id="loginFailed" path="en/loginFailed.jsp"/>
  </views>

  <views mode="de">
    <view id="loginRequired" path="de/loginRequired.jsp"/>
    <view id="loginFailed" path="de/loginFailed.jsp"/>
  </views>
  
  ...
</maverick>]]>
				</programlisting>
			</refsect1>
		</refentry>

		<refentry>
			<refnamediv>
				<refname>commands</refname>
				<refpurpose>
					Contains commands
				</refpurpose>
			</refnamediv>
			<refsynopsisdiv>
				<title>Synopsis</title>
				<refsect2>
					<title>Content</title>
					<para>
						commands ::= (command+)
					</para>
				</refsect2>
				<refsect2>
					<title>Attributes</title>
					<para>None</para>
				</refsect2>
			</refsynopsisdiv>
			<refsect1>
				<title>Descripton</title>
				<para>
					The <sgmltag>commands</sgmltag> element acts as a container
					for <sgmltag>command</sgmltag> elements.
				</para>
			</refsect1>
			<refsect1>
				<title>Attributes</title>
				<para>None</para>
			</refsect1>
			<refsect1>
				<title>Examples</title>
				<programlisting>
<![CDATA[<maverick version="2.0">
  <commands>
    <command name="welcome">
      ...
    </command>
    <command name="signup">
      ...
    </command>
  </commands>
</maverick>]]>
				</programlisting>
			</refsect1>
		</refentry>

		<refentry>
			<refnamediv>
				<refname>command</refname>
				<refpurpose>
					Defines the behavior of one command
				</refpurpose>
			</refnamediv>
			<refsynopsisdiv>
				<title>Synopsis</title>
				<refsect2>
					<title>Content</title>
					<para>
						command ::= (controller?, view+)
					</para>
				</refsect2>
				<refsect2>
					<title>Attributes</title>
					<informaltable frame="all">
						<tgroup cols="3">
							<thead>
								<row>
									<entry>Name</entry>
									<entry>Type</entry>
									<entry>Default</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>name</entry>
									<entry>CDATA</entry>
									<entry><emphasis>Required</emphasis></entry>
								</row>
							</tbody>
						</tgroup>
					</informaltable>
				</refsect2>
			</refsynopsisdiv>
			<refsect1>
				<title>Descripton</title>
				<para>
					A <sgmltag>command</sgmltag> is the basic unit of work in
					Maverick.  When an HTTP request is processed by Maverick,
					the URI is examined to determine which <sgmltag>command</sgmltag>
					to execute.  If no <sgmltag>command</sgmltag> matches the
					URI, Maverick returns 404.
				</para>
				<para>
					The contents of a <sgmltag>command</sgmltag> element determine
					the runtime behavior.  You can define a controller
					class and some number of views, one of which will be rendered
					for every request.
				</para>
				<para>
					Note that the <sgmltag>controller</sgmltag> child element
					is optional, but if it is left out, there can be only one
					<sgmltag>view</sgmltag> element since a controller is
					needed to select from the available views.
				</para>
			</refsect1>
			<refsect1>
				<title>Attributes</title>
				<formalpara>
					<title>name</title>
					<para>
						The URI to associate with this command, minus the context
						root, extension, or query parameters.  For example,
						"welcome" and "protected/reportDetail".
					</para>
				</formalpara>
			</refsect1>
			<refsect1>
				<title>Examples</title>
				<programlisting>
<![CDATA[<maverick version="2.0" default-view-type="document">
  <commands>
    <command name="welcome">
      <view path="hello.html"/>
    </command>
  </commands>
</maverick>]]>
				</programlisting>
			</refsect1>
		</refentry>

		<refentry>
			<refnamediv>
				<refname>controller</refname>
				<refpurpose>
					Associates a controller with a particular command
				</refpurpose>
			</refnamediv>
			<refsynopsisdiv>
				<title>Synopsis</title>
				<refsect2>
					<title>Content</title>
					<para>
						controller ::= (param*,<emphasis>[Special]</emphasis>)
					</para>
				</refsect2>
				<refsect2>
					<title>Attributes</title>
					<informaltable frame="all">
						<tgroup cols="3">
							<thead>
								<row>
									<entry>Name</entry>
									<entry>Type</entry>
									<entry>Default</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>class</entry>
									<entry>CDATA</entry>
									<entry><emphasis>Required</emphasis></entry>
								</row>
							</tbody>
						</tgroup>
					</informaltable>
				</refsect2>
			</refsynopsisdiv>
			<refsect1>
				<title>Descripton</title>
				<para>
					A controller is a user class which "controls" how the request is
					handled.  Here is where user code is executed, the model is
					prepared, and which view to render is chosen.
				</para>
				<para>
					<sgmltag>param</sgmltag> child elements populate the context
					params available from <function>ControllerContext.getControllerParams()</function>
					prior to execution of the controller.
				</para>
				<para>
					There are two types of controller classes, determined by whether
					or not the class implements
					<classname>org.infohazard.maverick.flow.Controller</classname> or
					<classname>org.infohazard.maverick.flow.ControllerSingleton</classname>.
				</para>
				<para>
					Normal controller objects are instantiated fresh for every request
					and disposed of afterwards.  Typically you will want to extend
					one of the abstract base classes in
					<classname>org.infohazard.maverick.ctl</classname> such as
					<classname>ThrowawayBean</classname> which provides helpful
					additional features such as populating bean properties from
					the request parameters.
				</para>
				<para>
					Singleton controllers resemble Struts controllers.  A single
					instance of each controller is instantiated for the entire
					webapp.  The XML contents of the <sgmltag>controller</sgmltag>
					element are passed to the controller object so that Form
					bean classes or other parameters may be configured.  For singletons,
					the structure of the XML contents of the <sgmltag>controller</sgmltag>
					node is arbitrary and freely interpreted by the controller
					instance.
				</para>
				<para>
					A <classname>SingletonController</classname> helper
					base class is provided with Maverick:  <classname>FormBeanUser</classname>.
					This is just one example which provides a very Struts-like
					action pattern.
				</para>
			</refsect1>
			<refsect1>
				<title>Attributes</title>
				<formalpara>
					<title>class</title>
					<para>
						The full name of the class which will act as the controller.
						This class must implement 
						<classname>org.infohazard.maverick.flow.Controller</classname> or
						<classname>org.infohazard.maverick.flow.ControllerSingleton</classname>.
					</para>
				</formalpara>
			</refsect1>
			<refsect1>
				<title>Examples</title>
				<programlisting>
<![CDATA[<maverick version="2.0" default-view-type="document">
  <commands>
    <command name="viewReport">
      <controller class="org.foo.Report">
        <param name="color" value="red"/>
      </controller>
      <view name="success" path="good.jsp"/>
      <view name="error" path="bad.jsp"/>
    </command>
  </commands>
</maverick>]]>
				</programlisting>
			</refsect1>
		</refentry>

		<refentry>
			<refnamediv>
				<refname>view</refname>
				<refpurpose>
					Defines a view as either part of a command or a globally referencable view
				</refpurpose>
			</refnamediv>
			<refsynopsisdiv>
				<title>Synopsis</title>
				<refsect2>
					<title>Content</title>
					<para>
						view ::= (param*,<emphasis>[Special]</emphasis>)
					</para>
				</refsect2>
				<refsect2>
					<title>Attributes</title>
					<informaltable frame="all">
						<tgroup cols="3">
							<thead>
								<row>
									<entry>Name</entry>
									<entry>Type</entry>
									<entry>Default</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>type</entry>
									<entry>One of the view factory types</entry>
									<entry>
										The value of the <sgmltag>default-view-type</sgmltag>
										attribute on the <sgmltag>maverick</sgmltag>
										element, or "document"
										if there is no explicit default.
									</entry>
								</row>
								<row>
									<entry>id</entry>
									<entry>CDATA</entry>
									<entry>
										<emphasis>Required if parent is <sgmltag>views</sgmltag></emphasis>
									</entry>
								</row>
								<row>
									<entry>name</entry>
									<entry>CDATA</entry>
									<entry>
										The value of <sgmltag>ref</sgmltag>
									</entry>
								</row>
								<row>
									<entry>ref</entry>
									<entry>A previously defined view id</entry>
									<entry>None</entry>
								</row>
								<row>
									<entry>mode</entry>
									<entry>CDATA</entry>
									<entry>None</entry>
								</row>
								<row>
									<entry><emphasis>[Special]</emphasis></entry>
									<entry></entry>
									<entry></entry>
								</row>
							</tbody>
						</tgroup>
					</informaltable>
				</refsect2>
			</refsynopsisdiv>
			<refsect1>
				<title>Descripton</title>
				<para>
					A view renders the model to the response.  There are many
					different types of views, defined by the view factories
					registered in the <sgmltag>modules</sgmltag> section.
					The interpretation of a <sgmltag>view</sgmltag> element
					is determined by the <sgmltag>type</sgmltag> attribute,
					or the default registered with Maverick.
				</para>
				<para>
					There are two places <sgmltag>view</sgmltag> elements
					can appear.  The first is as a global view defined
					under a <sgmltag>views</sgmltag> element.  In this case,
					the view <emphasis>must</emphasis> have an
					<sgmltag>id</sgmltag> attribute and <emphasis>cannot</emphasis>
					have a <sgmltag>name</sgmltag> or <sgmltag>ref</sgmltag>.
				</para>
				<para>
					The second place <sgmltag>view</sgmltag> elements can
					appear is under a <sgmltag>command</sgmltag> element.
					Here they are named (with the <sgmltag>name</sgmltag>
					attribute) and designate the options available in the
					command for rendering the model.  A <sgmltag>view</sgmltag>
					here can either completely define a new view or it can
					reference one of the globally defined views in a
					<sgmltag>views</sgmltag> section.  To link to a global
					view, simply use the global view's <sgmltag>id</sgmltag> as
					the value of the <sgmltag>ref</sgmltag> attribute.  As
					a convenience, the <sgmltag>name</sgmltag> defaults to
					the same value as the <sgmltag>ref</sgmltag>.
				</para>
				<para>
					Note that if a command defines only a single view,
					it does not need to be named.  Regardless of what the
					controller returns, the one view will be rendered.
				</para>
				<para>
					<sgmltag>param</sgmltag> child elements populate the context
					params available from <function>ViewContext.getViewParams()</function>
					prior to execution of the view.  The meaning of a param
					is specific to the particular View type.
				</para>
				<para>
					Other attributes and child elements are determined by
					the type of view.  Nevertheless, there are some common
					conventions which <classname>ViewFactory</classname>
					implementors are strongly encouraged to follow:
				</para>
				<itemizedlist>
					<listitem>
						<para>
							Path-like values should use the attribute
							<sgmltag>path</sgmltag>.
						</para>
					</listitem>
				</itemizedlist>
				<para>
					See the chapter on Internationalization and Shunting
					for a discussion of the <sgmltag>mode</sgmltag> attribute.
				</para>
			</refsect1>
			<refsect1>
				<title>Attributes</title>
				<formalpara>
					<title>type</title>
					<para>
						One of the types registered as a <sgmltag>view-factory</sgmltag>,
						or one of the defaults (redirect, document, trivial, null).
					</para>
				</formalpara>
				<formalpara>
					<title>id</title>
					<para>
						Must be present for global views defined in the
						<sgmltag>views</sgmltag> element.  Allows commands
						to reference the <sgmltag>id</sgmltag> of global
						views with the <sgmltag>ref</sgmltag> attribute.
					</para>
				</formalpara>
				<formalpara>
					<title>name</title>
					<para>
						For views defined in <sgmltag>command</sgmltag>
						elements, this is the string that the Controller
						will return to identify which view to render.
						Defaults to the value of <sgmltag>ref</sgmltag>.
						Can be omitted if there is only one view for a
						command.
					</para>
				</formalpara>
				<formalpara>
					<title>ref</title>
					<para>
						Links to the <sgmltag>id</sgmltag> of a global view.
					</para>
				</formalpara>
				<formalpara>
					<title>mode</title>
					<para>
						See the chapter on Internationalization and Shunting.
					</para>
				</formalpara>
			</refsect1>
			<refsect1>
				<title>Examples</title>
				<programlisting>
<![CDATA[<maverick version="2.0" default-view-type="document">
  <views>
    <view id="ugly" path="ugly.jsp"/>
    <view id="fugly" path="fugly.jsp"/>
  </views>
  <commands>
    <command name="viewReport">
      <controller class="org.foo.Report"/>
      <view name="good" path="good.jsp">
      	<param name="color" value="red"/>
      </view>
      <view name="bad" path="bad.jsp"/>
      <view ref="ugly"/>
      <view name="explicitname" ref="fugly"/>
    </command>
  </commands>
</maverick>]]>
				</programlisting>
			</refsect1>
		</refentry>

		<refentry>
			<refnamediv>
				<refname>transform</refname>
				<refpurpose>
					Defines a transform on views that support them
				</refpurpose>
			</refnamediv>
			<refsynopsisdiv>
				<title>Synopsis</title>
				<refsect2>
					<title>Content</title>
					<para>
						transform ::= (param*,<emphasis>[Special]</emphasis>)
					</para>
				</refsect2>
				<refsect2>
					<title>Attributes</title>
					<informaltable frame="all">
						<tgroup cols="3">
							<thead>
								<row>
									<entry>Name</entry>
									<entry>Type</entry>
									<entry>Default</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>type</entry>
									<entry>One of the transform factory types</entry>
									<entry>
										The value of the <sgmltag>default-transform-type</sgmltag>
										attribute on the <sgmltag>maverick</sgmltag>
										element, or "document" if there is no explicit default.
									</entry>
								</row>
								<row>
									<entry><emphasis>[Special]</emphasis></entry>
									<entry></entry>
									<entry></entry>
								</row>
							</tbody>
						</tgroup>
					</informaltable>
				</refsect2>
			</refsynopsisdiv>
			<refsect1>
				<title>Descripton</title>
				<para>
					A transform is some sort of arbitrary manipulation of
					view content performed immediately prior to dumping it
					to the response.  Most view types support transforms,
					but some (such as redirect) do not.  The canonical
					example of a transform is an XSLT transform, but
					there are other options such as DVSL and simple text
					"wrapping" transformations.
				</para>
				<para>
					Transforms are pluggable very much like views.  Factories
					are associated with types in the <sgmltag>modules</sgmltag>
					section, and <sgmltag>transform</sgmltag> elements within
					<sgmltag>view</sgmltag> element have a <sgmltag>type</sgmltag>
					attribute.  The content of a <sgmltag>transform</sgmltag>
					element (attributes, child elements) is determined by
					the type.
				</para>
				<para>
					By convention, path-like values should be expressed
					using a <sgmltag>path</sgmltag> attribute.
				</para>
				<para>
					Multiple transforms can be associated with a view
					by simply defining multiple <sgmltag>transform</sgmltag>
					elements.  All transforms need not be of the same type.
				</para>
				<para>
					<sgmltag>param</sgmltag> child elements populate the context
					params available from <function>TransformContext.getTransformParams()</function>
					prior to execution of the view.  The meaning of a param
					is specific to the transform type, but should be pretty obvious.
				</para>
				<para>
					Further documentation about the allowable options for
					various transform types is available in the javadocs
					for each factory.
				</para>
			</refsect1>
			<refsect1>
				<title>Attributes</title>
				<formalpara>
					<title>type</title>
					<para>
						One of the types registered as a
						<sgmltag>transform-factory</sgmltag>,
						or one of the defaults (document, xslt).
					</para>
				</formalpara>
			</refsect1>
			<refsect1>
				<title>Examples</title>
				<programlisting>
<![CDATA[<maverick version="2.0" default-view-type="document" default-transform-type="xslt">
  <commands>
    <command name="runQuery">
      <controller class="org.foo.Query"/>
      
      <view name="success" path="queryResults.jsp">
        <transform path="firstStage.xsl"/>
        <transform path="lookAndFeel.xsl"/>
      </view>
      
      <view name="error" path="queryError.jsp">
        <transform path="errorStage.xsl">
          <param name="color" value="red"/>
        </transform>
        <transform path="lookAndFeel.xsl"/>
      </view>
    </command>
  </commands>
</maverick>]]>
				</programlisting>
			</refsect1>
		</refentry>
	</appendix>

	<appendix id="faq">
		<title>Frequently Asked Questions</title>
		
		<qandaset defaultlabel="number">
			<qandaentry>
				<question>
					<para>Why did you choose the name Maverick?</para>
				</question>
				<answer>
					<para>
						Because it is a better name than Ambivalence.
					</para>
				</answer>
			</qandaentry>
			
			<qandaentry>
				<question>
					<para>Huh?</para>
				</question>
				<answer>
					<para>
						<command>grep -i m.*v.*c /usr/share/dict/words</command>
					</para>
				</answer>
			</qandaentry>
			
			<!-- 
			    This is probably not informative anymore; commons logging
			    works automatically.			    
			    
			<qandaentry>
				<question>
					<para>How do I initialize log4j?</para>
				</question>
				<answer>
					<para>
						There are a lot of possible ways to initialize log4j, and no one
						approach fits all.  For this reason, Maverick itself does not try
						to initialize log4j.  Here are some suggestions:
					</para>
					<formalpara>
						<title>Use container-wide default initialization</title>
						<para>
							Placing the <filename>log4j.jar</filename> in the container's
							shared classpath (<filename>tomcat/lib</filename>,
							<filename>orion/lib</filename>, etc), log4j can be initialized with
							so-called "default initialization" by running the JVM with
							<parameter>-Dlog4j.configuration=file:/path/to/log4j.properties</parameter>
							as a command-line parameter.  A sample
							<filename>log4j.properties</filename>
							which simply dumps all logging to the console is included with
							the Maverick distribution in the <filename>tools</filename>
							directory.
						</para>
					</formalpara>
					<formalpara>
						<title>Initialize log4j in your web application</title>
						<para>
							There are many reasons why a container-wide instance of log4j
							might not meet your needs.  You might have multiple webapps
							which require different versions of log4j.  You might want
							different webapps logged into different files.  In any case,
							this means you need a separate copy of
							<filename>log4j.jar</filename> in each
							web application's WAR file, and you need to perform some extra
							steps to initialize each instance.  Add
							<filename>log4j.jar</filename> to your <filename>WEB-INF/lib</filename>
							directory.  Then, create a special servlet which initializes
							log4j in the <function>init()</function> method.  For an
							example of such a servlet, search the
							<ulink url="http://jakarta.apache.org/log4j/docs/manual.html">log4j manual</ulink>
							for "Initialization servlet".
						</para>
					</formalpara>
				</answer>
			</qandaentry>
			-->

			<qandaentry>
				<question>
					<para>How can I split my maverick.xml into multiple files?</para>
				</question>
				<answer>
					<para>
						You can make the XML parser do the work for you.  Read this
						thread from the mailing list archives:
					</para>
					<para>
						http://www.mail-archive.com/mav-user@lists.sourceforge.net/msg00462.html
					</para>
				</answer>
			</qandaentry>
			
			<qandaentry>
				<question>
					<para>How can I use a Maverick command as the welcome page, like index.jsp?</para>
				</question>
				<answer>
					<para>
						You might have noticed that web containers won't let you specify a servlet
						as a welcome page.  The reason is that the container goes through a list
						of files, checking to see if they exist on the disk and if not trying
						the next one.  There are two solutions to this problem:
					</para>
					<itemizedlist>
						<listitem>
							<para>
								Create an index.jsp which contains &lt;jsp:forward page=&quot;yourCommand.m&quot;/&gt;.
								This adds the overhead of a forward. 
							</para>
						</listitem>
						<listitem>
							<para>
								Create an empty file called yourCommand.m.  The container will see this file and allow
								the request to process... which will then be handled normally as a servlet call.  Cheesey.
							</para>
						</listitem>
					</itemizedlist>
				</answer>
			</qandaentry>

			<qandaentry>
				<question>
					<para>Can I chain command invocations together?</para>
				</question>
				<answer>
					<para>
						Yes.  See the documentation for the "reuseMaverickContext" init-param to the Dispatcher. 
					</para>
				</answer>
			</qandaentry>
			
			<qandaentry>
				<question>
					<para>Does Maverick work with Tomcat 3.x?</para>
				</question>
				<answer>
					<para>
						It is not officially supported, but it can be made to work with
						some limitation.  In general, avoid transforming documents,
						although transformations of <classname>Node</classname> sources
						will work.  Also, since
						<classname>ThrowawayBean</classname> relies on
						<function>getParameterMap()</function>, you must derive your
						controllers from one of its superclasses, such as
						<classname>Throwaway</classname>.
					</para>
				</answer>
			</qandaentry>

			<qandaentry>
				<question>
					<para>How does Maverick compare to Struts?</para>
				</question>
				<answer>
					<para>
						TODO
					</para>
				</answer>
			</qandaentry>

			<qandaentry>
				<question>
					<para>How does Maverick compare to WebWork?</para>
				</question>
				<answer>
					<para>
						TODO
					</para>
				</answer>
			</qandaentry>

			<qandaentry>
				<question>
					<para>
						Why do I get a
						<classname>java.lang.NoClassDefFoundError</classname>
						when I start a Maverick application?
					</para>
				</question>
				<answer>
					<para>
						You are missing one of the jars that Maverick
						depends on.
						See the FAQ regarding what jars Maverick uses.
					</para>
				</answer>
			</qandaentry>

			<qandaentry>
				<question>
					<para>
						What jars does Maverick require?
					</para>
				</question>
				<answer>
					<para>
						Here is a list of all the jars currently used
						by the core (all available in the
						<filename>lib</filename> directory of the
						Maverick distribution):
					</para>
					<itemizedlist>
						<listitem><para><filename>commons-logging-1.0.3.jar</filename></para></listitem>
						<listitem><para><filename>jdom.jar</filename></para></listitem>
						<listitem><para><filename>commons-beanutils.jar</filename></para></listitem>
						<listitem><para><filename>commons-collections.jar</filename></para></listitem>
					</itemizedlist>
					<para>
						Note that other pluggable view or transform types may require
						additional jars; the best way is to open up the sample WARs
						and see what is there.
					</para>
					<para>
						Of couse, your environment will need the
						JAXP API and Servlet 2.3 API classes.
					</para>
				</answer>
			</qandaentry>

			<qandaentry>
				<question>
					<para>What public websites are using Maverick?</para>
				</question>
				<answer>
					<para>
						This list is not especially comprehensive:
					</para>
					<itemizedlist>
						<listitem>
							<para>
								<ulink url="http://www.similarity.com"/> - Jeff's pet
								project that spawned the original need for Maverick.
								Currently down for extensive revision.  The view layer
								is built with Velocity and "document" transforms.
							</para>
						</listitem>
						<listitem>
							<para>
								<ulink url="http://player.thesimsonline.ea.com"/> - the
								player community website for The Sims Online.  This is actually
								built as a hybrid MVC approach; while all form submissions
								go through the Maverick dispatcher, most pages use a special
								taglib to instantiate standard Maverick controllers inside the
								JSP.  This was necessary to satisfy the requirement that producers
								be able to add pages without "developer" interaction.  The view
								layer is built with JSP and JSTL.
							</para>
						</listitem>
						<listitem>
							<para>
								<ulink url="http://www.fluidiom.com"/> - An interesting
								experiment in memetics.
							</para>
						</listitem>
						<listitem>
							<para>
								<ulink url="http://www.richdad.com"/>
							</para>
						</listitem>
						<listitem>
							<para>
								<ulink url="http://www.burgerweeshuis.nl"/> - A Public 
								website for a pop culture platform with a custom content management 
								interface. Furthermore the website has a reservations module that is 
								used by several other dutch culture platforms.
							</para>
						</listitem>
					</itemizedlist>
				</answer>
			</qandaentry>
			
			<!-- Probably should put short bios in here
			<qandaentry>
				<question>
					<para>Who are the developers of Maverick?</para>
				</question>
				<answer>
					<para>
						Maverick is brought to you by:
					</para>
					<itemizedlist>
						<listitem>
							<formalpara>
								<title>Jeff Schnitzer</title>
								<para></para>
							</formalpara>
						</listitem>
						<listitem>
							<formalpara>
								<title>Scott Hernandez</title>
								<para></para>
							</formalpara>
						</listitem>
						<listitem>
							<formalpara>
								<title>Jim Moore</title>
								<para></para>
							</formalpara>
						</listitem>
					</itemizedlist>
				</answer>
			</qandaentry>
			-->
			
		</qandaset>
	</appendix>

</book>

