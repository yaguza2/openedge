/* This file was generated by SableCC (http://www.sablecc.org/). */

package nl.openedge.gaps.support.berekeningen.parser;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;

import nl.openedge.gaps.support.berekeningen.analysis.Analysis;
import nl.openedge.gaps.support.berekeningen.analysis.AnalysisAdapter;
import nl.openedge.gaps.support.berekeningen.lexer.Lexer;
import nl.openedge.gaps.support.berekeningen.lexer.LexerException;
import nl.openedge.gaps.support.berekeningen.node.ABlock;
import nl.openedge.gaps.support.berekeningen.node.ACallExp;
import nl.openedge.gaps.support.berekeningen.node.ACastMinusExp;
import nl.openedge.gaps.support.berekeningen.node.ACastPlusExp;
import nl.openedge.gaps.support.berekeningen.node.ADivExp;
import nl.openedge.gaps.support.berekeningen.node.AIdExp;
import nl.openedge.gaps.support.berekeningen.node.AMinusExp;
import nl.openedge.gaps.support.berekeningen.node.AMultExp;
import nl.openedge.gaps.support.berekeningen.node.ANumberExp;
import nl.openedge.gaps.support.berekeningen.node.APlusExp;
import nl.openedge.gaps.support.berekeningen.node.EOF;
import nl.openedge.gaps.support.berekeningen.node.NodeCast;
import nl.openedge.gaps.support.berekeningen.node.PBlock;
import nl.openedge.gaps.support.berekeningen.node.PExp;
import nl.openedge.gaps.support.berekeningen.node.Start;
import nl.openedge.gaps.support.berekeningen.node.Switchable;
import nl.openedge.gaps.support.berekeningen.node.TFuncid;
import nl.openedge.gaps.support.berekeningen.node.TId;
import nl.openedge.gaps.support.berekeningen.node.TNumber;
import nl.openedge.gaps.support.berekeningen.node.Token;
import nl.openedge.gaps.support.berekeningen.node.TypedLinkedList;

public class Parser
{

	public final Analysis ignoredTokens = new AnalysisAdapter();

	protected ArrayList nodeList;

	private final Lexer lexer;

	private final ListIterator stack = new LinkedList().listIterator();

	private int last_shift;

	private int last_pos;

	private int last_line;

	private Token last_token;

	private final TokenIndex converter = new TokenIndex();

	private final int[] action = new int[2];

	private final static int SHIFT = 0;

	private final static int REDUCE = 1;

	private final static int ACCEPT = 2;

	private final static int ERROR = 3;

	public Parser(Lexer lexer)
	{
		this.lexer = lexer;

		if (actionTable == null)
		{
			try
			{
				DataInputStream s = new DataInputStream(new BufferedInputStream(
						Parser.class.getResourceAsStream("parser.dat")));

				// read actionTable
				int length = s.readInt();
				actionTable = new int[length][][];
				for (int i = 0; i < actionTable.length; i++)
				{
					length = s.readInt();
					actionTable[i] = new int[length][3];
					for (int j = 0; j < actionTable[i].length; j++)
					{
						for (int k = 0; k < 3; k++)
						{
							actionTable[i][j][k] = s.readInt();
						}
					}
				}

				// read gotoTable
				length = s.readInt();
				gotoTable = new int[length][][];
				for (int i = 0; i < gotoTable.length; i++)
				{
					length = s.readInt();
					gotoTable[i] = new int[length][2];
					for (int j = 0; j < gotoTable[i].length; j++)
					{
						for (int k = 0; k < 2; k++)
						{
							gotoTable[i][j][k] = s.readInt();
						}
					}
				}

				// read errorMessages
				length = s.readInt();
				errorMessages = new String[length];
				for (int i = 0; i < errorMessages.length; i++)
				{
					length = s.readInt();
					StringBuffer buffer = new StringBuffer();

					for (int j = 0; j < length; j++)
					{
						buffer.append(s.readChar());
					}
					errorMessages[i] = buffer.toString();
				}

				// read errors
				length = s.readInt();
				errors = new int[length];
				for (int i = 0; i < errors.length; i++)
				{
					errors[i] = s.readInt();
				}

				s.close();
			}
			catch (Exception e)
			{
				throw new RuntimeException(
						"The file \"parser.dat\" is either missing or corrupted.");
			}
		}
	}

	private int goTo(int index)
	{
		int state = state();
		int low = 1;
		int high = gotoTable[index].length - 1;
		int value = gotoTable[index][0][1];

		while (low <= high)
		{
			int middle = (low + high) / 2;

			if (state < gotoTable[index][middle][0])
			{
				high = middle - 1;
			}
			else if (state > gotoTable[index][middle][0])
			{
				low = middle + 1;
			}
			else
			{
				value = gotoTable[index][middle][1];
				break;
			}
		}

		return value;
	}

	private void push(int numstate, ArrayList listNode) throws ParserException,
			LexerException, IOException
	{
		this.nodeList = listNode;

		if (!stack.hasNext())
		{
			stack.add(new State(numstate, this.nodeList));
			return;
		}

		State s = (State) stack.next();
		s.state = numstate;
		s.nodes = this.nodeList;
	}

	private int state()
	{
		State s = (State) stack.previous();
		stack.next();
		return s.state;
	}

	private ArrayList pop()
	{
		return (ArrayList) ((State) stack.previous()).nodes;
	}

	private int index(Switchable token)
	{
		converter.index = -1;
		token.apply(converter);
		return converter.index;
	}

	public Start parse() throws ParserException, LexerException, IOException
	{
		push(0, null);

		List ign = null;
		while (true)
		{
			while (index(lexer.peek()) == -1)
			{
				if (ign == null)
				{
					ign = new TypedLinkedList(NodeCast.instance);
				}

				ign.add(lexer.next());
			}

			if (ign != null)
			{
				ignoredTokens.setIn(lexer.peek(), ign);
				ign = null;
			}

			last_pos = lexer.peek().getPos();
			last_line = lexer.peek().getLine();
			last_token = lexer.peek();

			int index = index(lexer.peek());
			action[0] = actionTable[state()][0][1];
			action[1] = actionTable[state()][0][2];

			int low = 1;
			int high = actionTable[state()].length - 1;

			while (low <= high)
			{
				int middle = (low + high) / 2;

				if (index < actionTable[state()][middle][0])
				{
					high = middle - 1;
				}
				else if (index > actionTable[state()][middle][0])
				{
					low = middle + 1;
				}
				else
				{
					action[0] = actionTable[state()][middle][1];
					action[1] = actionTable[state()][middle][2];
					break;
				}
			}

			switch (action[0])
			{
				case SHIFT:
				{
					ArrayList list = new ArrayList();
					list.add(lexer.next());
					push(action[1], list);
					last_shift = action[1];
				}
					break;
				case REDUCE:
					switch (action[1])
					{

						case 0:
						{
							ArrayList list = new0();
							push(goTo(0), list);
						}
							break;

						case 1:
						{
							ArrayList list = new1();
							push(goTo(1), list);
						}
							break;

						case 2:
						{
							ArrayList list = new2();
							push(goTo(1), list);
						}
							break;

						case 3:
						{
							ArrayList list = new3();
							push(goTo(1), list);
						}
							break;

						case 4:
						{
							ArrayList list = new4();
							push(goTo(1), list);
						}
							break;

						case 5:
						{
							ArrayList list = new5();
							push(goTo(1), list);
						}
							break;

						case 6:
						{
							ArrayList list = new6();
							push(goTo(2), list);
						}
							break;

						case 7:
						{
							ArrayList list = new7();
							push(goTo(2), list);
						}
							break;

						case 8:
						{
							ArrayList list = new8();
							push(goTo(2), list);
						}
							break;

						case 9:
						{
							ArrayList list = new9();
							push(goTo(3), list);
						}
							break;

						case 10:
						{
							ArrayList list = new10();
							push(goTo(3), list);
						}
							break;

						case 11:
						{
							ArrayList list = new11();
							push(goTo(3), list);
						}
							break;

						case 12:
						{
							ArrayList list = new12();
							push(goTo(3), list);
						}
							break;

						case 13:
						{
							ArrayList list = new13();
							push(goTo(4), list);
						}
							break;

						case 14:
						{
							ArrayList list = new14();
							push(goTo(4), list);
						}
							break;

						case 15:
						{
							ArrayList list = new15();
							push(goTo(5), list);
						}
							break;

						case 16:
						{
							ArrayList list = new16();
							push(goTo(6), list);
						}
							break;

						case 17:
						{
							ArrayList list = new17();
							push(goTo(6), list);
						}
							break;

					}
					break;
				case ACCEPT:
				{
					EOF node2 = (EOF) lexer.next();
					PBlock node1 = (PBlock) ((ArrayList) pop()).get(0);
					Start node = new Start(node1, node2);
					return node;
				}
				case ERROR:
					throw new ParserException(last_token, "["
							+ last_line + "," + last_pos + "] "
							+ errorMessages[errors[action[1]]]);
			}
		}
	}

	ArrayList new0()
	{
		ArrayList nodeList = new ArrayList();

		ArrayList nodeArrayList1 = (ArrayList) pop();
		PBlock pblockNode1;
		{
			PExp pexpNode2;
			pexpNode2 = (PExp) nodeArrayList1.get(0);

			pblockNode1 = new ABlock(pexpNode2);
		}
		nodeList.add(pblockNode1);
		return nodeList;
	}

	ArrayList new1()
	{
		ArrayList nodeList = new ArrayList();

		ArrayList nodeArrayList2 = (ArrayList) pop();
		ArrayList nodeArrayList1 = (ArrayList) pop();
		PExp pexpNode1;
		{
			PExp pexpNode2;
			pexpNode2 = (PExp) nodeArrayList2.get(0);

			pexpNode1 = new ACastPlusExp(pexpNode2);
		}
		nodeList.add(pexpNode1);
		return nodeList;
	}

	ArrayList new2()
	{
		ArrayList nodeList = new ArrayList();

		ArrayList nodeArrayList2 = (ArrayList) pop();
		ArrayList nodeArrayList1 = (ArrayList) pop();
		PExp pexpNode1;
		{
			PExp pexpNode2;
			pexpNode2 = (PExp) nodeArrayList2.get(0);

			pexpNode1 = new ACastMinusExp(pexpNode2);
		}
		nodeList.add(pexpNode1);
		return nodeList;
	}

	ArrayList new3()
	{
		ArrayList nodeList = new ArrayList();

		ArrayList nodeArrayList3 = (ArrayList) pop();
		ArrayList nodeArrayList2 = (ArrayList) pop();
		ArrayList nodeArrayList1 = (ArrayList) pop();
		PExp pexpNode1;
		{
			PExp pexpNode2;
			PExp pexpNode3;
			pexpNode2 = (PExp) nodeArrayList1.get(0);
			pexpNode3 = (PExp) nodeArrayList3.get(0);

			pexpNode1 = new APlusExp(pexpNode2, pexpNode3);
		}
		nodeList.add(pexpNode1);
		return nodeList;
	}

	ArrayList new4()
	{
		ArrayList nodeList = new ArrayList();

		ArrayList nodeArrayList3 = (ArrayList) pop();
		ArrayList nodeArrayList2 = (ArrayList) pop();
		ArrayList nodeArrayList1 = (ArrayList) pop();
		PExp pexpNode1;
		{
			PExp pexpNode2;
			PExp pexpNode3;
			pexpNode2 = (PExp) nodeArrayList1.get(0);
			pexpNode3 = (PExp) nodeArrayList3.get(0);

			pexpNode1 = new AMinusExp(pexpNode2, pexpNode3);
		}
		nodeList.add(pexpNode1);
		return nodeList;
	}

	ArrayList new5()
	{
		ArrayList nodeList = new ArrayList();

		ArrayList nodeArrayList1 = (ArrayList) pop();
		PExp pexpNode1;
		pexpNode1 = (PExp) nodeArrayList1.get(0);
		nodeList.add(pexpNode1);
		return nodeList;
	}

	ArrayList new6()
	{
		ArrayList nodeList = new ArrayList();

		ArrayList nodeArrayList3 = (ArrayList) pop();
		ArrayList nodeArrayList2 = (ArrayList) pop();
		ArrayList nodeArrayList1 = (ArrayList) pop();
		PExp pexpNode1;
		{
			PExp pexpNode2;
			PExp pexpNode3;
			pexpNode2 = (PExp) nodeArrayList1.get(0);
			pexpNode3 = (PExp) nodeArrayList3.get(0);

			pexpNode1 = new AMultExp(pexpNode2, pexpNode3);
		}
		nodeList.add(pexpNode1);
		return nodeList;
	}

	ArrayList new7()
	{
		ArrayList nodeList = new ArrayList();

		ArrayList nodeArrayList3 = (ArrayList) pop();
		ArrayList nodeArrayList2 = (ArrayList) pop();
		ArrayList nodeArrayList1 = (ArrayList) pop();
		PExp pexpNode1;
		{
			PExp pexpNode2;
			PExp pexpNode3;
			pexpNode2 = (PExp) nodeArrayList1.get(0);
			pexpNode3 = (PExp) nodeArrayList3.get(0);

			pexpNode1 = new ADivExp(pexpNode2, pexpNode3);
		}
		nodeList.add(pexpNode1);
		return nodeList;
	}

	ArrayList new8()
	{
		ArrayList nodeList = new ArrayList();

		ArrayList nodeArrayList1 = (ArrayList) pop();
		PExp pexpNode1;
		pexpNode1 = (PExp) nodeArrayList1.get(0);
		nodeList.add(pexpNode1);
		return nodeList;
	}

	ArrayList new9()
	{
		ArrayList nodeList = new ArrayList();

		ArrayList nodeArrayList1 = (ArrayList) pop();
		PExp pexpNode1;
		{
			TNumber tnumberNode2;
			tnumberNode2 = (TNumber) nodeArrayList1.get(0);

			pexpNode1 = new ANumberExp(tnumberNode2);
		}
		nodeList.add(pexpNode1);
		return nodeList;
	}

	ArrayList new10()
	{
		ArrayList nodeList = new ArrayList();

		ArrayList nodeArrayList1 = (ArrayList) pop();
		PExp pexpNode1;
		{
			TId tidNode2;
			tidNode2 = (TId) nodeArrayList1.get(0);

			pexpNode1 = new AIdExp(tidNode2);
		}
		nodeList.add(pexpNode1);
		return nodeList;
	}

	ArrayList new11()
	{
		ArrayList nodeList = new ArrayList();

		ArrayList nodeArrayList4 = (ArrayList) pop();
		ArrayList nodeArrayList3 = (ArrayList) pop();
		ArrayList nodeArrayList2 = (ArrayList) pop();
		ArrayList nodeArrayList1 = (ArrayList) pop();
		PExp pexpNode1;
		{
			TFuncid tfuncidNode2;
			TypedLinkedList listNode4 = new TypedLinkedList();
			tfuncidNode2 = (TFuncid) nodeArrayList1.get(0);
			{
				TypedLinkedList listNode3 = new TypedLinkedList();
				listNode3 = (TypedLinkedList) nodeArrayList3.get(0);
				if (listNode3 != null)
				{
					listNode4.addAll(listNode3);
				}
			}

			pexpNode1 = new ACallExp(tfuncidNode2, listNode4);
		}
		nodeList.add(pexpNode1);
		return nodeList;
	}

	ArrayList new12()
	{
		ArrayList nodeList = new ArrayList();

		ArrayList nodeArrayList3 = (ArrayList) pop();
		ArrayList nodeArrayList2 = (ArrayList) pop();
		ArrayList nodeArrayList1 = (ArrayList) pop();
		PExp pexpNode1;
		pexpNode1 = (PExp) nodeArrayList2.get(0);
		nodeList.add(pexpNode1);
		return nodeList;
	}

	ArrayList new13()
	{
		ArrayList nodeList = new ArrayList();

		ArrayList nodeArrayList1 = (ArrayList) pop();
		TypedLinkedList listNode2 = new TypedLinkedList();
		{
			PExp pexpNode1;
			pexpNode1 = (PExp) nodeArrayList1.get(0);
			if (pexpNode1 != null)
			{
				listNode2.add(pexpNode1);
			}
		}
		nodeList.add(listNode2);
		return nodeList;
	}

	ArrayList new14()
	{
		ArrayList nodeList = new ArrayList();

		ArrayList nodeArrayList2 = (ArrayList) pop();
		ArrayList nodeArrayList1 = (ArrayList) pop();
		TypedLinkedList listNode3 = new TypedLinkedList();
		{
			PExp pexpNode1;
			TypedLinkedList listNode2 = new TypedLinkedList();
			pexpNode1 = (PExp) nodeArrayList1.get(0);
			listNode2 = (TypedLinkedList) nodeArrayList2.get(0);
			if (pexpNode1 != null)
			{
				listNode3.add(pexpNode1);
			}
			if (listNode2 != null)
			{
				listNode3.addAll(listNode2);
			}
		}
		nodeList.add(listNode3);
		return nodeList;
	}

	ArrayList new15()
	{
		ArrayList nodeList = new ArrayList();

		ArrayList nodeArrayList2 = (ArrayList) pop();
		ArrayList nodeArrayList1 = (ArrayList) pop();
		PExp pexpNode1;
		pexpNode1 = (PExp) nodeArrayList2.get(0);
		nodeList.add(pexpNode1);
		return nodeList;
	}

	ArrayList new16()
	{
		ArrayList nodeList = new ArrayList();

		ArrayList nodeArrayList1 = (ArrayList) pop();
		TypedLinkedList listNode2 = new TypedLinkedList();
		{
			PExp pexpNode1;
			pexpNode1 = (PExp) nodeArrayList1.get(0);
			if (pexpNode1 != null)
			{
				listNode2.add(pexpNode1);
			}
		}
		nodeList.add(listNode2);
		return nodeList;
	}

	ArrayList new17()
	{
		ArrayList nodeList = new ArrayList();

		ArrayList nodeArrayList2 = (ArrayList) pop();
		ArrayList nodeArrayList1 = (ArrayList) pop();
		TypedLinkedList listNode3 = new TypedLinkedList();
		{
			TypedLinkedList listNode1 = new TypedLinkedList();
			PExp pexpNode2;
			listNode1 = (TypedLinkedList) nodeArrayList1.get(0);
			pexpNode2 = (PExp) nodeArrayList2.get(0);
			if (listNode1 != null)
			{
				listNode3.addAll(listNode1);
			}
			if (pexpNode2 != null)
			{
				listNode3.add(pexpNode2);
			}
		}
		nodeList.add(listNode3);
		return nodeList;
	}

	private static int[][][] actionTable;

	/*
	 * { {{-1, ERROR, 0}, {0, SHIFT, 1}, {2, SHIFT, 2}, {3, SHIFT, 3}, {9, SHIFT, 4}, {10,
	 * SHIFT, 5}, {11, SHIFT, 6}, }, {{-1, ERROR, 1}, {0, SHIFT, 1}, {2, SHIFT, 2}, {3,
	 * SHIFT, 3}, {9, SHIFT, 4}, {10, SHIFT, 5}, {11, SHIFT, 6}, }, {{-1, ERROR, 2}, {0,
	 * SHIFT, 1}, {9, SHIFT, 4}, {10, SHIFT, 5}, {11, SHIFT, 6}, }, {{-1, ERROR, 3}, {0,
	 * SHIFT, 1}, {9, SHIFT, 4}, {10, SHIFT, 5}, {11, SHIFT, 6}, }, {{-1, REDUCE, 9}, },
	 * {{-1, REDUCE, 10}, }, {{-1, ERROR, 6}, {0, SHIFT, 14}, }, {{-1, ERROR, 7}, {12,
	 * ACCEPT, -1}, }, {{-1, REDUCE, 0}, {2, SHIFT, 15}, {3, SHIFT, 16}, }, {{-1, REDUCE,
	 * 5}, {4, SHIFT, 17}, {5, SHIFT, 18}, }, {{-1, REDUCE, 8}, }, {{-1, ERROR, 11}, {1,
	 * SHIFT, 19}, {2, SHIFT, 15}, {3, SHIFT, 16}, }, {{-1, REDUCE, 1}, {4, SHIFT, 17},
	 * {5, SHIFT, 18}, }, {{-1, REDUCE, 2}, {4, SHIFT, 17}, {5, SHIFT, 18}, }, {{-1,
	 * ERROR, 14}, {0, SHIFT, 1}, {2, SHIFT, 2}, {3, SHIFT, 3}, {9, SHIFT, 4}, {10, SHIFT,
	 * 5}, {11, SHIFT, 6}, }, {{-1, ERROR, 15}, {0, SHIFT, 1}, {9, SHIFT, 4}, {10, SHIFT,
	 * 5}, {11, SHIFT, 6}, }, {{-1, ERROR, 16}, {0, SHIFT, 1}, {9, SHIFT, 4}, {10, SHIFT,
	 * 5}, {11, SHIFT, 6}, }, {{-1, ERROR, 17}, {0, SHIFT, 1}, {9, SHIFT, 4}, {10, SHIFT,
	 * 5}, {11, SHIFT, 6}, }, {{-1, ERROR, 18}, {0, SHIFT, 1}, {9, SHIFT, 4}, {10, SHIFT,
	 * 5}, {11, SHIFT, 6}, }, {{-1, REDUCE, 12}, }, {{-1, REDUCE, 13}, {2, SHIFT, 15}, {3,
	 * SHIFT, 16}, {6, SHIFT, 26}, }, {{-1, ERROR, 21}, {1, SHIFT, 29}, }, {{-1, REDUCE,
	 * 3}, {4, SHIFT, 17}, {5, SHIFT, 18}, }, {{-1, REDUCE, 4}, {4, SHIFT, 17}, {5, SHIFT,
	 * 18}, }, {{-1, REDUCE, 6}, }, {{-1, REDUCE, 7}, }, {{-1, ERROR, 26}, {0, SHIFT, 1},
	 * {2, SHIFT, 2}, {3, SHIFT, 3}, {9, SHIFT, 4}, {10, SHIFT, 5}, {11, SHIFT, 6}, },
	 * {{-1, REDUCE, 16}, }, {{-1, REDUCE, 14}, {6, SHIFT, 26}, }, {{-1, REDUCE, 11}, },
	 * {{-1, REDUCE, 15}, {2, SHIFT, 15}, {3, SHIFT, 16}, }, {{-1, REDUCE, 17}, }, };
	 */
	private static int[][][] gotoTable;

	/*
	 * { {{-1, 7}, }, {{-1, 8}, {1, 11}, {14, 20}, {26, 30}, }, {{-1, 9}, {2, 12}, {3,
	 * 13}, {15, 22}, {16, 23}, }, {{-1, 10}, {17, 24}, {18, 25}, }, {{-1, 21}, }, {{-1,
	 * 27}, {28, 31}, }, {{-1, 28}, }, };
	 */
	private static String[] errorMessages;

	/*
	 * { "expecting: '(', '+', '-', number, id, funcid", "expecting: '(', number, id,
	 * funcid", "expecting: ')', '+', '-', '*', '/', ',', EOF", "expecting: '('",
	 * "expecting: EOF", "expecting: '+', '-', EOF", "expecting: ')', '+', '-'",
	 * "expecting: ')', '+', '-', ','", "expecting: ')'", "expecting: ')', ','", };
	 */
	private static int[] errors;
	/*
	 * { 0, 0, 1, 1, 2, 2, 3, 4, 5, 2, 2, 6, 2, 2, 0, 1, 1, 1, 1, 2, 7, 8, 2, 2, 2, 2, 0,
	 * 9, 9, 2, 7, 9, };
	 */
}